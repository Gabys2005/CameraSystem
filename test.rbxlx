<roblox version="4">
  <Item class="ServerScriptService" referent="0">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">TestEZ</string>
        <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Context</string>
          <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">Expectation</string>
          <string name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end

function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()
			return self
		end)
	end

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

-- Make alias public on class
Expectation.an = Expectation.a

--[[
	Assert that our expectation value is truthy
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called.
	An optional error message can be passed to assert that the error message
	contains the given value.
]]
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(self.successCondition,
			("Expected function to throw an error containing %q, but it %s"):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			("Expected function to never throw an error containing %q, but it threw: %s"):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(
				tostring(err)
			)
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">ExpectationContext</string>
          <string name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}
ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end

function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end

function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">LifecycleHooks</string>
          <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="6">
        <Properties>
          <string name="Name">Reporters</string>
        </Properties>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">TeamCityReporter</string>
            <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">TextReporter</string>
            <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">TextReporterQuiet</string>
            <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">TestBootstrap</string>
          <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">TestEnum</string>
          <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">TestPlan</string>
          <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = setmetatable({
		extend = function(...)
			error("Cannot call \"expect.extend\" from within a \"describe\" node.")
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	-- Copy 'script' directly to new env to make Studio debugger happy.
	-- Studio debugger does not look into __index, because of security reasons
	callbackEnv.script = originalEnv.script
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">TestPlanner</string>
          <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">TestResults</string>
          <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="15">
        <Properties>
          <string name="Name">TestRunner</string>
          <string name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end

		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. debug.traceback(tostring(message), 2)
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				if not testSuccess then
					return false, testErrorMessage .. "\nWhile cleaning up the failed test another error was found:\n" .. errorMessage
				end
				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="16">
        <Properties>
          <string name="Name">TestSession</string>
          <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)
	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)
	table.insert(self.expectationContextStack, expectationContext)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end


function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")
	return self.expectationContextStack[#self.expectationContextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="17">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="18">
      <Properties>
        <string name="Name">MainModule</string>
        <string name="Source"><![CDATA[return function(systemFolder)
	--// Services
	local players = game:GetService("Players")
	local replicatedStorage = game:GetService("ReplicatedStorage")

	--// Variables
	local Settings = require(systemFolder.Settings)
	local replicatedFolder = script.Replicated
	local data = require(replicatedFolder.Data)
	local apiModule = script.Apis.Api

	--// Functions
	local function onPlayerAdded(plr)
		if table.find(Settings.GuiOwners, plr.Name) then
			local guiClone = script.Guis.Controls:Clone()
			guiClone.Name = "CameraSystemControls"
			guiClone.Parent = plr.PlayerGui
		end
		local mainGuiClone = script.Guis.Main:Clone()
		mainGuiClone.Name = "CameraSystemMain"
		mainGuiClone.Parent = plr.PlayerGui
	end

	--===================== CODE =====================--

	--// Check if the system can run
	assert(
		workspace.StreamingEnabled == false,
		"[[ Camera System ]]: StreamingEnabled can't be enabled for the cameras to work, disable it in Workspace's properties"
	)

	--// Validate settings
	assert(Settings.GuiOwners, "[[ Camera System ]]: 'GuiOwners' setting is missing")
	assert(typeof(Settings.GuiOwners) == "table", "[[ Camera System ]]: 'GuiOwners' setting has to be a table")
	for i, v in pairs(Settings.GuiOwners) do
		assert(typeof(v) == "string", "[[ Camera System ]]: '" .. v .. "' isn't a string in 'GuiOwners' setting")
	end

	--// Import all assets neccessary
	replicatedFolder.Name = "CameraSystem"
	replicatedFolder.Parent = replicatedStorage
	apiModule.Parent = systemFolder
	--// Get cameras
	local api = require(apiModule)
	local camerasByIds = api:GetCamsById()

	data.Shared.CurrentCamera.Type = "Default"
	data.Shared.CurrentCamera.Model = camerasByIds.Default

	print(camerasByIds)

	--// Connect events
	for i, v in pairs(players:GetPlayers()) do
		onPlayerAdded(v)
	end
	players.PlayerAdded:Connect(onPlayerAdded)

	replicatedFolder.Events.RequestCurrentData.OnServerInvoke = function()
		return data
	end

	replicatedFolder.Events.ChangeCam.OnServerEvent:Connect(function(plr, camType, camId)
		api:ChangeCam(camType, camId)
	end)
end
]]></string>
      </Properties>
      <Item class="Folder" referent="19">
        <Properties>
          <string name="Name">Apis</string>
        </Properties>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">Api</string>
            <string name="Source">local api = {}
local replicated = game:GetService("ReplicatedStorage")
local replicatedFolder = replicated:WaitForChild("CameraSystem")
local workspaceFolder = workspace:WaitForChild("CameraSystem")
local data = require(replicatedFolder.Data)
local run = game:GetService("RunService")

local camerasByIds = {
	Static = {},
	Moving = {},
	Default = nil
}

--// Shared apis
function api:GetCamsById()
    warn("running get cams by id")
	if not camerasByIds.Default then
        warn("indexing")
		camerasByIds.Static = idCameraFolder(workspaceFolder.Cameras.Static)
		camerasByIds.Moving = idCameraFolder(workspaceFolder.Cameras.Moving)
		if workspaceFolder.Cameras:FindFirstChild("Default") then
			camerasByIds.Default = workspaceFolder.Cameras.Default.CFrame
		else
			warn("[[ Camera System ]]: Default camera is missing, using first static camera or fallback position instead")
			camerasByIds.Default = camerasByIds.Static[1] and camerasByIds.Static[1].CFrame or CFrame.new(0,10,0)
		end
	end
	return camerasByIds
end

function api:GetCamById(camType,camId)
    if not camerasByIds then api:getCamsById() end
    print(camerasByIds)
    return camerasByIds[camType][camId]
end

function api:GetDefaultCamPosition()
    return camerasByIds.Default
end

--// Server only apis
if run:IsServer() then
    function api:ChangeCam(camType,camId)
        data.Shared.CurrentCamera.Type = camType
        data.Shared.CurrentCamera.Id = camId
        data.Shared.CurrentCamera.Model = camerasByIds[camType][camId]
        replicatedFolder.Events.ChangeCam:FireAllClients(camType,camId)
    end
end

--// Client only apis
-- if run:IsClient() then
    
-- end

--// Other junk
function idCameraFolder(folder)
	local camById = {}
	if folder then
		for i,v in pairs(folder:GetChildren()) do
			v:SetAttribute("ID",i)
			camById[i] = v
		end
	end
	return camById
end

return api</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">ClientApi</string>
            <string name="Source">local clientApi = {}</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">ServerApi</string>
            <string name="Source">local api = {}
local replicated = game:GetService("ReplicatedStorage")
local replicatedFolder = replicated:WaitForChild("CameraSystem")
local workspaceFolder = workspace:WaitForChild("CameraSystem")
local data = require(replicatedFolder.Data)

local camerasByIds = {
	Static = {},
	Moving = {},
	Default = nil
}

function api:ChangeCam(camType,camId)
	data.Shared.CurrentCamera.Type = camType
	data.Shared.CurrentCamera.Id = camId
	data.Shared.CurrentCamera.Model = camerasByIds[camType][camId]
	replicatedFolder.Events.ChangeCam:FireAllClients(camType,camId)
end

function api:GetCamsById()
	if not camerasByIds.Default then
		idCameraFolder(workspaceFolder.Cameras.Static)
		idCameraFolder(workspaceFolder.Cameras.Moving)
		if workspaceFolder.Cameras:FindFirstChild("Default") then
			camerasByIds.Default = workspaceFolder.Cameras.Default.CFrame
		else
			warn("[[ Camera System ]]: Default camera is missing, using first static camera or fallback position instead")
			camerasByIds.Default = camerasByIds.Static[1] and camerasByIds.Static[1].CFrame or CFrame.new(0,10,0)
		end
	end
	return camerasByIds
end

function idCameraFolder(folder)
	local camById = {}
	if folder then
		for i,v in pairs(folder:GetChildren()) do
			v:SetAttribute("ID",i)
			camById[i] = v
		end
	end
	return camById
end

return api</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="23">
        <Properties>
          <string name="Name">Guis</string>
        </Properties>
        <Item class="ScreenGui" referent="24">
          <Properties>
            <string name="Name">Controls</string>
          </Properties>
          <Item class="LocalScript" referent="25">
            <Properties>
              <string name="Name">Main</string>
              <string name="Source">--// Services
local replicatedStorage = game:GetService("ReplicatedStorage")

--// Variables
local replicated = replicatedStorage:WaitForChild("CameraSystem")
local topbarPlusReference = replicatedStorage:FindFirstChild("TopbarPlusReference")
local iconModule = replicated.Client.Dependencies.TopbarPlus
local menuNames = {
	{
		Name = "Cameras",
		Width = 220,
		Height = 300
	},
	{
		Name = "Settings",
		Width = 220,
		Height = 150
	}
}
local window = require(replicated.Client.Scripts.NewWindow)

--// Functions

--===================== CODE =====================--
if topbarPlusReference then
	iconModule = topbarPlusReference.Value
end
local Icon = require(iconModule)

window:setParent(script.Parent)

local menuIcons = {}
for i,v in pairs(menuNames) do
	local gui = window:new({
		Title = v.Name,
		Name = v.Name,
		MinimumWidth = v.Width,
		MinimumHeight = v.Height,
		Enabled = false
	})
	local icon = Icon.new():setLabel(v.Name):bindToggleItem(gui)
	icon.deselectWhenOtherIconSelected = false
	table.insert(menuIcons,icon)
end
local controlIcon = Icon.new():setImage(5036765717):setMenu(menuIcons)</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ScreenGui" referent="26">
          <Properties>
            <string name="Name">Main</string>
          </Properties>
          <Item class="LocalScript" referent="27">
            <Properties>
              <string name="Name">Main</string>
              <string name="Source">--// Services
local replicatedStorage = game:GetService("ReplicatedStorage")
local run = game:GetService("RunService")

--// Variables
local replicated = replicatedStorage:WaitForChild("CameraSystem")
local topbarPlusReference = replicatedStorage:FindFirstChild("TopbarPlusReference")
local iconModule = replicated.Client.Dependencies.TopbarPlus
local data = require(replicated.Client.Scripts.UpdateData)
local directData = data:getModule()
local api = require(workspace:WaitForChild("CameraSystem"):WaitForChild("Api"))
local cameraInstance = workspace.CurrentCamera

--// Functions

--===================== CODE =====================--
api:GetCamsById() -- index
require(replicated.Client.Scripts.CameraController)

replicated.Events.ChangeCam.OnClientEvent:Connect(function(camType,camId)
	data:set("Shared.CurrentCamera",{
		Type = camType,
		Id = camId,
		Model = api:GetCamById(camType,camId)
	})
end)</string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="28">
        <Properties>
          <string name="Name">Replicated</string>
        </Properties>
        <Item class="Folder" referent="29">
          <Properties>
            <string name="Name">Client</string>
          </Properties>
          <Item class="Folder" referent="30">
            <Properties>
              <string name="Name">Dependencies</string>
            </Properties>
            <Item class="ModuleScript" referent="31">
              <Properties>
                <string name="Name">TopbarPlus</string>
                <string name="Source">--[[ icon:header
[themes]: https://1foreverhd.github.io/TopbarPlus/features/#themes
[set method]: https://1foreverhd.github.io/TopbarPlus/api/icon/#set

## Construtors

#### new
```lua
local icon = Icon.new()
```
Constructs an empty ``32x32`` icon on the topbar.

----



## Methods

#### set
{chainable}
```lua
icon:set(settingName, value, iconState)
```
Applies a specific setting to an icon. All settings can be found [here](https://github.com/1ForeverHD/TopbarPlus/blob/main/src/Icon/Themes/Default.lua). If the setting falls under the 'toggleable' category then an iconState can be specified. For most scenarious it's recommended instead to apply settings using [themes].

----
#### get
```lua
local value = icon:get(settingName, iconState)
```
Retrieves the given settings value. If the setting falls under the 'toggleable' category then an iconState can be specified.

----
#### getToggleState
```lua
local selectedOrDeselectedString = icon:getToggleState()
```
Returns the current toggleState, either "deselected" or "selected".

----
#### setTheme
{chainable}
```lua
icon:setTheme(theme)
```
Applies a theme to the given icon. See [themes] for more information.

----
#### setEnabled
{chainable}
```lua
icon:setEnabled(bool)
```
When set to ``false``, the icon will be disabled and hidden.

----
#### setName
{chainable}
```lua
icon:setName(string)
```
Associates the given name to the icon which enables it to be retrieved with ``IconController.getIcon(name)``.

----
#### setProperty
{chainable}
```lua
icon:setProperty(propertyName, value)
```
An alternative way of doing ``zone[propertyName] = value``. This enables the easy-configuration of icon properties within chained methods.

----
#### select
{chainable}
```lua
icon:select()
```
Selects the icon (as if it were clicked once).

----
#### deselect
{chainable}
```lua
icon:deselect()
```
Deselects the icon (as if it were clicked, then clicked again).

----
#### notify
{chainable}
```lua
icon:notify(clearNoticeEvent)
```
Prompts a notice bubble which accumulates the further it is prompted. If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.

----
#### clearNotices
{chainable}
```lua
icon:clearNotices()
```

----
#### disableStateOverlay
{chainable}
```lua
icon:disableStateOverlay(bool)
```
When set to ``true``, disables the shade effect which appears when the icon is pressed and released.

----
#### convertLabelToNumberSpinner
{chainable}
```lua
icon:convertLabelToNumberSpinner(numberSpinner)
```
Takes a [NumberSpinner](https://devforum.roblox.com/t/numberspinner-module/1105961) object (by boatbomber) and converts it into the icons label.

Example usage:

```lua
Icon.new()
    :setName("CashSpinnerIcon")
    :setRight()
    :lock()
    :setSize(100, 32)
    :give(function(icon)
        local NumberSpinner = require(replicatedStorage.NumberSpinner)
        local labelSpinner = NumberSpinner.new()
        icon:convertLabelToNumberSpinner(labelSpinner)
        labelSpinner.Name = "LabelSpinner"
        labelSpinner.Decimals = 3
        labelSpinner.Duration = 0.25
        coroutine.wrap(function()
            while wait(0.5) do
                labelSpinner.Value = math.random(100000)/1000
            end
        end)()
    end)
```

----
#### setImage
{chainable} {toggleable}
```lua
icon:setImage(imageId, iconState)
```
Applies an image to the icon based on the given ``imaageId``. ``imageId`` can be an assetId or a complete asset string.

----
#### setLabel
{chainable} {toggleable}
```lua
icon:setLabel(text, iconState)
```

----
#### setOrder
{chainable} {toggleable}
```lua
icon:setOrder(order, iconState)
```

----
#### setCornerRadius
{chainable} {toggleable}
```lua
icon:setCornerRadius(scale, offset, iconState)
```

----
#### setLeft
{chainable} {toggleable}
```lua
icon:setLeft(iconState)
```

----
#### setMid
{chainable} {toggleable}
```lua
icon:setMid(iconState)
```

----
#### setRight
{chainable} {toggleable}
```lua
icon:setRight(iconState)
```

----
#### setImageYScale
{chainable} {toggleable}
```lua
icon:setImageYScale(YScale, iconState)
```
Defines the proportional space the icons image takes up within the icons container.

----
#### setImageRatio
{chainable} {toggleable}
```lua
icon:setImageRatio(ratio, iconState)
```
Defines the x:y ratio dimensions as a number. By default ``ratio`` is ``1.00``.

----
#### setLabelYScale
{chainable} {toggleable}
```lua
icon:setLabelYScale(YScale, iconState)
```
Defines how large label text appears.By default ``YScale`` is ``0.45``.

----
#### setBaseZIndex
{chainable} {toggleable}
```lua
icon:setBaseZIndex(ZIndex, iconState)
```
Calculates the difference between the existing baseZIndex (i.e. ``instances.iconContainer.ZIndex``) and new value, then updates the ZIndex of all objects within the icon accoridngly using this difference.

----
#### setSize
{chainable} {toggleable}
```lua
icon:setSize(XOffset, YOffset, iconState)
```
Determines the icons container size. By default ``XOffset`` and ``YOffset`` are ``32``.

----
#### bindToggleItem
{chainable}
```lua
icon:bindToggleItem(guiObjectOrLayerCollector)
```
Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.

----
#### unbindToggleItem
{chainable}
```lua
icon:unbindToggleItem(guiObjectOrLayerCollector)
```
Unbinds the given GuiObject or LayerCollector from the toggle.

----
#### bindEvent
{chainable}
```lua
icon:bindEvent(iconEventName, eventFunction)
```
Connects to an [icon event](https://1foreverhd.github.io/TopbarPlus/api/icon/#events) based upon the given ``iconEventName`` and call ``eventFunction`` with arguments ``(self, ...)`` when the event is triggered.

----
#### unbindEvent
{chainable}
```lua
icon:unbindEvent(iconEventName)
```
Unbinds the connection of the associated ``iconEventName``.

----
#### bindToggleKey
{chainable}
```lua
icon:bindToggleKey(keyCodeEnum)
```
Binds a [keycode](https://developer.roblox.com/en-us/api-reference/enum/KeyCode) which toggles the icon when pressed.

----
#### unbindToggleKey
{chainable}
```lua
icon:unbindToggleKey(keyCodeEnum)
```
Unbinds the given keycode.

----
#### give
{chainable}
```lua
icon:give(userdata)
```
Passes the given userdata to the Icons maid to be destroyed/disconnected on the icons destruction. If a function is passed, it will be executed right away with its self (the icon) being passed as the first argument. The return value is then given to the maid (instead of the function).

----
#### lock
{chainable}
```lua
icon:lock()
```
Prevents the icon from being pressed and toggled.

----
#### unlock
{chainable}
```lua
icon:unlock()
```
Enables the icon to be pressed and toggled.

----
#### setTopPadding
{chainable}
```lua
icon:setTopPadding(offset, scale)
```
The gap between the top of the screen and the icon.

----
#### setTip
{chainable}
```lua
icon:setTip(text)
```
Sets a tip. To remove, pass ``nil`` as ``text``.

----
#### setCaption
{chainable}
```lua
icon:setCaption(text)
```
Sets a caption. To remove, pass ``nil`` as ``text``.

----
#### join
{chainable}
```lua
icon:join(parentIcon, featureName)
```
Parents the icon to the given parentIcon under the specified feature, either "dropdown" or "menu".

----
#### leave
{chainable}
```lua
icon:leave()
```
Unparents an icon from a parentIcon if it belongs to a dropdown or menu.

----
#### setDropdown
{chainable}
```lua
icon:setDropdown(arrayOfIcons)
```
Creates a vertical dropdown based upon the given ``table array`` of ``icons``. Pass an empty table ``{}`` to remove the dropdown. Dropdown settings can be configured using [themes] or the [set method].

----
#### setMenu
{chainable}
```lua
icon:setMenu(arrayOfIcons)
```
Creates a horizontal menu based upon the given ``table array`` of ``icons``. Pass an empty table ``{}`` to remove the menu. Menu settings can be configured using [themes] or the [set method].

----
#### destroy
{chainable}
```lua
icon:destroy()
```
Clears all connections and destroys all instances associated with the icon.

----



## Events
#### selected 
```lua
icon.selected:Connect(function()
    print("The icon was selected")
end)
```

----
#### deselected 
```lua
icon.deselected:Connect(function()
    print("The icon was deselected")
end)
```

----
#### toggled 
```lua
icon.toggled:Connect(function(isSelected)
    print(("The icon was %s"):format(icon:getToggleState(isSelected)))
end)
```

----
#### hoverStarted 
```lua
icon.hoverStarted:Connect(function()
    print("A mouse, finger or controller selection is hovering over the icon")
end)
```

----
#### hoverEnded 
```lua
icon.hoverEnded:Connect(function()
    print("The item is no longer hovering over the icon")
end)
```

----
#### dropdownOpened 
```lua
icon.dropdownOpened:Connect(function()
    print("The dropdown was opened")
end)
```

----
#### dropdownClosed 
```lua
icon.dropdownClosed:Connect(function()
    print("The dropdown was closed")
end)
```

----
#### menuOpened 
```lua
icon.menuOpened:Connect(function()
    print("The menu was opened")
end)
```

----
#### menuClosed 
```lua
icon.menuClosed:Connect(function()
    print("The menu was closed")
end)
```

----
#### notified 
```lua
icon.notified:Connect(function()
    print("New notice")
end)
```

----



## Properties
#### deselectWhenOtherIconSelected
```lua
local bool = icon.deselectWhenOtherIconSelected --[default: 'true']
```
A bool deciding whether the icon will be deselected when another icon is selected. Defaults to ``true``.

----
#### accountForWhenDisabled
```lua
local bool = icon.accountForWhenDisabled --[default: 'false']
```
A bool deciding whether to continue accounting for and updating the icons position on the topbar when disabled

----
#### name
{read-only}
```lua
local string = icon.name --[default: '"Unnamed Icon"']
```

----
#### isSelected
{read-only}
```lua
local bool = icon.isSelected
```

----
#### enabled
{read-only}
```lua
local bool = icon.enabled
```

----
#### hovering
{read-only}
```lua
local bool = icon.hovering
```

----
#### tipText
{read-only}
```lua
local stringOrNil = icon.tipText
```

----
#### captionText
{read-only}
```lua
local stringOrNil = icon.captionText
```

----
#### totalNotices
{read-only}
```lua
local int = icon.totalNotices
```

----
#### dropdownIcons
{read-only}
```lua
local arrayOfIcons = icon.dropdownIcons
```

----
#### menuIcons
{read-only}
```lua
local arrayOfIcons = icon.menuIcons
```

----
#### dropdownOpen
{read-only}
```lua
local bool = icon.dropdownOpen
```

----
#### menuOpen
{read-only}
```lua
local bool = icon.menuOpen
```

----
#### locked
{read-only}
```lua
local bool = icon.locked
```

----
#### topPadding
{read-only}
```lua
local udim = icon.topPadding
```

----
#### targetPosition
{read-only}
```lua
local udim2 = icon.targetPosition
```
The position the icon is at or aims to move to.
--]]



-- LOCAL
local tweenService = game:GetService("TweenService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local debris = game:GetService("Debris")
local userInputService = game:GetService("UserInputService")
local httpService = game:GetService("HttpService") -- This is to generate GUIDs
local runService = game:GetService("RunService")
local textService = game:GetService("TextService")
local guiService = game:GetService("GuiService")
local starterGui = game:GetService("StarterGui")
local players = game:GetService("Players")
local IconController = require(script.IconController)
local Signal = require(script.Signal)
local Maid = require(script.Maid)
local TopbarPlusGui = require(script.TopbarPlusGui)
local TopbarPlusReference = require(script.TopbarPlusReference)
local referenceObject = TopbarPlusReference.getObject()
local Themes = require(script.Themes)
local activeItems = TopbarPlusGui.ActiveItems
local topbarContainer = TopbarPlusGui.TopbarContainer
local iconTemplate = topbarContainer["IconContainer"]
local DEFAULT_THEME = Themes.Default
local THUMB_OFFSET = 55
local DEFAULT_FORCED_GROUP_VALUES = {}
local Icon = (referenceObject and require(referenceObject.Value)) or {}
Icon.__index = Icon
if not referenceObject then
	TopbarPlusReference.addToReplicatedStorage()
end



-- CONSTRUCTORS
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	-- Maids (for autocleanup)
	local maid = Maid.new()
	self._maid = maid
	self._hoveringMaid = maid:give(Maid.new())
	self._dropdownClippingMaid = maid:give(Maid.new())
	self._menuClippingMaid = maid:give(Maid.new())

	-- These are the GuiObjects that make up the icon
	local instances = {}
	self.instances = instances
	local iconContainer = maid:give(iconTemplate:Clone())
	iconContainer.Visible = true
	iconContainer.Parent = topbarContainer
	instances["iconContainer"] = iconContainer
	instances["iconButton"] = iconContainer.IconButton
	instances["iconImage"] = instances.iconButton.IconImage
	instances["iconLabel"] = instances.iconButton.IconLabel
	instances["iconGradient"] = instances.iconButton.IconGradient
	instances["iconCorner"] = instances.iconButton.IconCorner
	instances["iconOverlay"] = iconContainer.IconOverlay
	instances["iconOverlayCorner"] = instances.iconOverlay.IconOverlayCorner
	instances["noticeFrame"] = instances.iconButton.NoticeFrame
	instances["noticeLabel"] = instances.noticeFrame.NoticeLabel
	instances["captionContainer"] = iconContainer.CaptionContainer
	instances["captionFrame"] = instances.captionContainer.CaptionFrame
	instances["captionLabel"] = instances.captionContainer.CaptionLabel
	instances["captionCorner"] = instances.captionFrame.CaptionCorner
	instances["captionOverlineContainer"] = instances.captionContainer.CaptionOverlineContainer
	instances["captionOverline"] = instances.captionOverlineContainer.CaptionOverline
	instances["captionOverlineCorner"] = instances.captionOverline.CaptionOverlineCorner
	instances["captionVisibilityBlocker"] = instances.captionFrame.CaptionVisibilityBlocker
	instances["captionVisibilityCorner"] = instances.captionVisibilityBlocker.CaptionVisibilityCorner
	instances["tipFrame"] = iconContainer.TipFrame
	instances["tipLabel"] = instances.tipFrame.TipLabel
	instances["tipCorner"] = instances.tipFrame.TipCorner
	instances["dropdownContainer"] = iconContainer.DropdownContainer
	instances["dropdownFrame"] = instances.dropdownContainer.DropdownFrame
	instances["dropdownList"] = instances.dropdownFrame.DropdownList
	instances["menuContainer"] = iconContainer.MenuContainer
	instances["menuFrame"] = instances.menuContainer.MenuFrame
	instances["menuList"] = instances.menuFrame.MenuList
	instances["clickSound"] = iconContainer.ClickSound

	-- These determine and describe how instances behave and appear
	self._settings = {
		action = {
			["toggleTransitionInfo"] = {},
			["resizeInfo"] = {},
			["repositionInfo"] = {},
			["captionFadeInfo"] = {},
			["tipFadeInfo"] = {},
			["dropdownSlideInfo"] = {},
			["menuSlideInfo"] = {},
		},
		toggleable = {
			["iconBackgroundColor"] = {instanceNames = {"iconButton"}, propertyName = "BackgroundColor3"},
			["iconBackgroundTransparency"] = {instanceNames = {"iconButton"}, propertyName = "BackgroundTransparency"},
			["iconCornerRadius"] = {instanceNames = {"iconCorner", "iconOverlayCorner"}, propertyName = "CornerRadius"},
			["iconGradientColor"] = {instanceNames = {"iconGradient"}, propertyName = "Color"},
			["iconGradientRotation"] = {instanceNames = {"iconGradient"}, propertyName = "Rotation"},
			["iconImage"] = {callMethods = {self._updateIconSize}, instanceNames = {"iconImage"}, propertyName = "Image"},
			["iconImageColor"] = {instanceNames = {"iconImage"}, propertyName = "ImageColor3"},
			["iconImageTransparency"] = {instanceNames = {"iconImage"}, propertyName = "ImageTransparency"},
			["iconScale"] = {instanceNames = {"iconButton"}, propertyName = "Size"},
			["forcedIconSize"] = {},
			["iconSize"] = {callSignals = {self.updated}, callMethods = {self._updateIconSize}, instanceNames = {"iconContainer"}, propertyName = "Size", tweenAction = "resizeInfo"},
			["iconOffset"] = {instanceNames = {"iconButton"}, propertyName = "Position"},
			["iconText"] = {callMethods = {self._updateIconSize}, instanceNames = {"iconLabel"}, propertyName = "Text"},
			["iconTextColor"] = {instanceNames = {"iconLabel"}, propertyName = "TextColor3"},
			["iconFont"] = {instanceNames = {"iconLabel"}, propertyName = "Font"},
			["iconImageYScale"] = {callMethods = {self._updateIconSize}},
			["iconImageRatio"] = {callMethods = {self._updateIconSize}},
			["iconLabelYScale"] = {callMethods = {self._updateIconSize}},
			["noticeCircleColor"] = {instanceNames = {"noticeFrame"}, propertyName = "ImageColor3"},
			["noticeCircleImage"] = {instanceNames = {"noticeFrame"}, propertyName = "Image"},
			["noticeTextColor"] = {instanceNames = {"noticeLabel"}, propertyName = "TextColor3"},
			["noticeImageTransparency"] = {instanceNames = {"noticeFrame"}, propertyName = "ImageTransparency"},
			["noticeTextTransparency"] = {instanceNames = {"noticeLabel"}, propertyName = "TextTransparency"},
			["baseZIndex"] = {callMethods = {self._updateBaseZIndex}},
			["order"] = {callSignals = {self.updated}, instanceNames = {"iconContainer"}, propertyName = "LayoutOrder"},
			["alignment"] = {callSignals = {self.updated}, callMethods = {self._updateDropdown}},
			["iconImageVisible"] = {instanceNames = {"iconImage"}, propertyName = "Visible"},
			["iconImageAnchorPoint"] = {instanceNames = {"iconImage"}, propertyName = "AnchorPoint"},
			["iconImagePosition"] = {instanceNames = {"iconImage"}, propertyName = "Position", tweenAction = "resizeInfo"},
			["iconImageSize"] = {instanceNames = {"iconImage"}, propertyName = "Size", tweenAction = "resizeInfo"},
			["iconImageTextXAlignment"] = {instanceNames = {"iconImage"}, propertyName = "TextXAlignment"},
			["iconLabelVisible"] = {instanceNames = {"iconLabel"}, propertyName = "Visible"},
			["iconLabelAnchorPoint"] = {instanceNames = {"iconLabel"}, propertyName = "AnchorPoint"},
			["iconLabelPosition"] = {instanceNames = {"iconLabel"}, propertyName = "Position", tweenAction = "resizeInfo"},
			["iconLabelSize"] = {instanceNames = {"iconLabel"}, propertyName = "Size", tweenAction = "resizeInfo"},
			["iconLabelTextXAlignment"] = {instanceNames = {"iconLabel"}, propertyName = "TextXAlignment"},
			["iconLabelTextSize"] = {instanceNames = {"iconLabel"}, propertyName = "TextSize"},
			["noticeFramePosition"] = {instanceNames = {"noticeFrame"}, propertyName = "Position"},
			["clickSoundId"] = {instanceNames = {"clickSound"}, propertyName = "SoundId"},
			["clickVolume"] = {instanceNames = {"clickSound"}, propertyName = "Volume"},
			["clickPlaybackSpeed"] = {instanceNames = {"clickSound"}, propertyName = "PlaybackSpeed"},
			["clickTimePosition"] = {instanceNames = {"clickSound"}, propertyName = "TimePosition"},
		},
		other = {
			["captionBackgroundColor"] = {instanceNames = {"captionFrame"}, propertyName = "BackgroundColor3"},
			["captionBackgroundTransparency"] = {instanceNames = {"captionFrame"}, propertyName = "BackgroundTransparency", group = "caption"},
			["captionBlockerTransparency"] = {instanceNames = {"captionVisibilityBlocker"}, propertyName = "BackgroundTransparency", group = "caption"},
			["captionOverlineColor"] = {instanceNames = {"captionOverline"}, propertyName = "BackgroundColor3"},
			["captionOverlineTransparency"] = {instanceNames = {"captionOverline"}, propertyName = "BackgroundTransparency", group = "caption"},
			["captionTextColor"] = {instanceNames = {"captionLabel"}, propertyName = "TextColor3"},
			["captionTextTransparency"] = {instanceNames = {"captionLabel"}, propertyName = "TextTransparency", group = "caption"},
			["captionFont"] = {instanceNames = {"captionLabel"}, propertyName = "Font"},
			["captionCornerRadius"] = {instanceNames = {"captionCorner", "captionOverlineCorner", "captionVisibilityCorner"}, propertyName = "CornerRadius"},
			["tipBackgroundColor"] = {instanceNames = {"tipFrame"}, propertyName = "BackgroundColor3"},
			["tipBackgroundTransparency"] = {instanceNames = {"tipFrame"}, propertyName = "BackgroundTransparency", group = "tip"},
			["tipTextColor"] = {instanceNames = {"tipLabel"}, propertyName = "TextColor3"},
			["tipTextTransparency"] = {instanceNames = {"tipLabel"}, propertyName = "TextTransparency", group = "tip"},
			["tipFont"] = {instanceNames = {"tipLabel"}, propertyName = "Font"},
			["tipCornerRadius"] = {instanceNames = {"tipCorner"}, propertyName = "CornerRadius"},
			["dropdownSize"] = {instanceNames = {"dropdownContainer"}, propertyName = "Size", unique = "dropdown"},
			["dropdownCanvasSize"] = {instanceNames = {"dropdownFrame"}, propertyName = "CanvasSize"},
			["dropdownMaxIconsBeforeScroll"] = {callMethods = {self._updateDropdown}},
			["dropdownMinWidth"] = {callMethods = {self._updateDropdown}},
			["dropdownSquareCorners"] = {callMethods = {self._updateDropdown}},
			["dropdownBindToggleToIcon"] = {},
			["dropdownToggleOnLongPress"] = {},
			["dropdownToggleOnRightClick"] = {},
			["dropdownCloseOnTapAway"] = {},
			["dropdownHidePlayerlistOnOverlap"] = {},
			["dropdownListPadding"] = {callMethods = {self._updateDropdown}, instanceNames = {"dropdownList"}, propertyName = "Padding"},
			["dropdownAlignment"] = {callMethods = {self._updateDropdown}},
			["dropdownScrollBarColor"] = {instanceNames = {"dropdownFrame"}, propertyName = "ScrollBarImageColor3"},
			["dropdownScrollBarTransparency"] = {instanceNames = {"dropdownFrame"}, propertyName = "ScrollBarImageTransparency"},
			["dropdownScrollBarThickness"] = {instanceNames = {"dropdownFrame"}, propertyName = "ScrollBarThickness"},
			["dropdownIgnoreClipping"] = {callMethods = {self._dropdownIgnoreClipping}},
			["menuSize"] = {instanceNames = {"menuContainer"}, propertyName = "Size", unique = "menu"},
			["menuCanvasSize"] = {instanceNames = {"menuFrame"}, propertyName = "CanvasSize"},
			["menuMaxIconsBeforeScroll"] = {callMethods = {self._updateMenu}},
			["menuBindToggleToIcon"] = {},
			["menuToggleOnLongPress"] = {},
			["menuToggleOnRightClick"] = {},
			["menuCloseOnTapAway"] = {},
			["menuListPadding"] = {callMethods = {self._updateMenu}, instanceNames = {"menuList"}, propertyName = "Padding"},
			["menuDirection"] = {callMethods = {self._updateMenu}},
			["menuScrollBarColor"] = {instanceNames = {"menuFrame"}, propertyName = "ScrollBarImageColor3"},
			["menuScrollBarTransparency"] = {instanceNames = {"menuFrame"}, propertyName = "ScrollBarImageTransparency"},
			["menuScrollBarThickness"] = {instanceNames = {"menuFrame"}, propertyName = "ScrollBarThickness"},
			["menuIgnoreClipping"] = {callMethods = {self._menuIgnoreClipping}},
		}
	}

	---------------------------------
	self._groupSettings = {}
	for _, settingsDetails in pairs(self._settings) do
		for settingName, settingDetail in pairs(settingsDetails) do
			local group = settingDetail.group
			if group then
				local groupSettings = self._groupSettings[group]
				if not groupSettings then
					groupSettings = {}
					self._groupSettings[group] = groupSettings
				end
				table.insert(groupSettings, settingName)
				settingDetail.forcedGroupValue = DEFAULT_FORCED_GROUP_VALUES[group]
				settingDetail.useForcedGroupValue = true
			end
		end
	end
	---------------------------------

	-- The setting values themselves will be set within _settings
	-- Setup a dictionary to make it quick and easy to reference setting by name
	self._settingsDictionary = {}
	-- Some instances require unique behaviours. These are defined with the 'unique' key
	-- for instance, we only want caption transparency effects to be applied on hovering
	self._uniqueSettings = {}
	self._uniqueSettingsDictionary = {}
	self.uniqueValues = {}
	local uniqueBehaviours = {
		["dropdown"] = function(settingName, instance, propertyName, value)
			local tweenInfo = self:get("dropdownSlideInfo")
			local bindToggleToIcon = self:get("dropdownBindToggleToIcon")
			local hidePlayerlist = self:get("dropdownHidePlayerlistOnOverlap") == true and self:get("alignment") == "right"
			local dropdownContainer = self.instances.dropdownContainer
			local dropdownFrame = self.instances.dropdownFrame
			local newValue = value
			local isOpen = true
			local isDeselected = not self.isSelected
			if bindToggleToIcon == false then
				isDeselected = not self.dropdownOpen
			end
			local isSpecialPressing = self._longPressing or self._rightClicking
			if self._tappingAway or (isDeselected and not isSpecialPressing) or (isSpecialPressing and self.dropdownOpen) then 
				local dropdownSize = self:get("dropdownSize")
				local XOffset = (dropdownSize and dropdownSize.X.Offset/1) or 0
				newValue = UDim2.new(0, XOffset, 0, 0)
				isOpen = false
			end
			if #self.dropdownIcons > 0 and isOpen and hidePlayerlist then
				if starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList) then
					starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
				end
				IconController._bringBackPlayerlist = (IconController._bringBackPlayerlist and IconController._bringBackPlayerlist + 1) or 1
				self._bringBackPlayerlist = true
			elseif self._bringBackPlayerlist and not isOpen and IconController._bringBackPlayerlist then
				IconController._bringBackPlayerlist -= 1
				if IconController._bringBackPlayerlist &lt;= 0 then
					IconController._bringBackPlayerlist = nil
					starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
				end
				self._bringBackPlayerlist = nil
			end
			local tween = tweenService:Create(instance, tweenInfo, {[propertyName] = newValue})
			local connection
			connection = tween.Completed:Connect(function()
				connection:Disconnect()
				--dropdownContainer.ClipsDescendants = not self.dropdownOpen
			end)
			tween:Play()
			if isOpen then
				dropdownFrame.CanvasPosition = self._dropdownCanvasPos
			else
				self._dropdownCanvasPos = dropdownFrame.CanvasPosition
			end
			self.dropdownOpen = isOpen
			self:_decideToCallSignal("dropdown")
		end,
		["menu"] = function(settingName, instance, propertyName, value)
			local tweenInfo = self:get("menuSlideInfo")
			local bindToggleToIcon = self:get("menuBindToggleToIcon")
			local menuContainer = self.instances.menuContainer
			local menuFrame = self.instances.menuFrame
			local newValue = value
			local isOpen = true
			local isDeselected = not self.isSelected
			if bindToggleToIcon == false then
				isDeselected = not self.menuOpen
			end
			local isSpecialPressing = self._longPressing or self._rightClicking
			if self._tappingAway or (isDeselected and not isSpecialPressing) or (isSpecialPressing and self.menuOpen) then 
				local menuSize = self:get("menuSize")
				local YOffset = (menuSize and menuSize.Y.Offset/1) or 0
				newValue = UDim2.new(0, 0, 0, YOffset)
				isOpen = false
			end
			if isOpen ~= self.menuOpen then
				self.updated:Fire()
			end
			if isOpen and tweenInfo.EasingDirection == Enum.EasingDirection.Out then
				tweenInfo = TweenInfo.new(tweenInfo.Time, tweenInfo.EasingStyle, Enum.EasingDirection.In)
			end
			local tween = tweenService:Create(instance, tweenInfo, {[propertyName] = newValue})
			local connection
			connection = tween.Completed:Connect(function()
				connection:Disconnect()
				--menuContainer.ClipsDescendants = not self.menuOpen
			end)
			tween:Play()
			if isOpen then
				if self._menuCanvasPos then
					menuFrame.CanvasPosition = self._menuCanvasPos
				end
			else
				self._menuCanvasPos = menuFrame.CanvasPosition
			end
			self.menuOpen = isOpen
			self:_decideToCallSignal("menu")
		end,
	}
	for settingsType, settingsDetails in pairs(self._settings) do
		for settingName, settingDetail in pairs(settingsDetails) do
			if settingsType == "toggleable" then
				settingDetail.values = settingDetail.values or {
					deselected = nil,
					selected = nil,
				}
			else
				settingDetail.value = nil
			end
			settingDetail.additionalValues = {}
			settingDetail.type = settingsType
			self._settingsDictionary[settingName] = settingDetail
			--
			local uniqueCat = settingDetail.unique
			if uniqueCat then
				local uniqueCatArray = self._uniqueSettings[uniqueCat] or {}
				table.insert(uniqueCatArray, settingName)
				self._uniqueSettings[uniqueCat] = uniqueCatArray
				self._uniqueSettingsDictionary[settingName] = uniqueBehaviours[uniqueCat]
			end
			--
		end
	end
	
	-- Signals (events)
	self.updated = maid:give(Signal.new())
	self.selected = maid:give(Signal.new())
    self.deselected = maid:give(Signal.new())
    self.toggled = maid:give(Signal.new())
	self.hoverStarted = maid:give(Signal.new())
	self.hoverEnded = maid:give(Signal.new())
	self.dropdownOpened = maid:give(Signal.new())
	self.dropdownClosed = maid:give(Signal.new())
	self.menuOpened = maid:give(Signal.new())
	self.menuClosed = maid:give(Signal.new())
	self.notified = maid:give(Signal.new())
	self._endNotices = maid:give(Signal.new())
	self._ignoreClippingChanged = maid:give(Signal.new())
	
	-- Connections
	-- This enables us to chain icons and features like menus and dropdowns together without them being hidden by parent frame with ClipsDescendants enabled
	local function setFeatureChange(featureName, value)
		local parentIcon = self._parentIcon
		self:set(featureName.."IgnoreClipping", value)
		if value == true and parentIcon then
			local connection = parentIcon._ignoreClippingChanged:Connect(function(_, value)
				self:set(featureName.."IgnoreClipping", value)
			end)
			local endConnection
			endConnection = self[featureName.."Closed"]:Connect(function()
				endConnection:Disconnect()
				connection:Disconnect()
			end)
		end
	end
	self.dropdownOpened:Connect(function()
		setFeatureChange("dropdown", true)
	end)
	self.dropdownClosed:Connect(function()
		setFeatureChange("dropdown", false)
	end)
	self.menuOpened:Connect(function()
		setFeatureChange("menu", true)
	end)
	self.menuClosed:Connect(function()
		setFeatureChange("menu", false)
	end)
	--]]

	-- Properties
	self.deselectWhenOtherIconSelected = true
	self.name = ""
	self.isSelected = false
	self.presentOnTopbar = true
	self.accountForWhenDisabled = false
	self.enabled = true
	self.hovering = false
	self.tipText = nil
	self.captionText = nil
	self.totalNotices = 0
	self.notices = {}
	self.dropdownIcons = {}
	self.menuIcons = {}
	self.dropdownOpen = false
	self.menuOpen = false
	self.locked = false
	self.topPadding = UDim.new(0, 4)
	self.targetPosition = nil
	self.toggleItems = {}
	self.lockedSettings = {}
	
	-- Private Properties
	self._draggingFinger = false
	self._updatingIconSize = true
	self._previousDropdownOpen = false
	self._previousMenuOpen = false
	self._bindedToggleKeys = {}
	self._bindedEvents = {}
	
	-- Apply start values
	self:setName("UnnamedIcon")
	self:setTheme(DEFAULT_THEME, true)

	-- Input handlers
	-- Calls deselect/select when the icon is clicked
	--[[instances.iconButton.MouseButton1Click:Connect(function()
		if self._draggingFinger then
			return false
		elseif self.isSelected then
			self:deselect()
			return true
		end
		self:select()
	end)--]]
	instances.iconButton.MouseButton1Click:Connect(function()
		if self.isSelected then
			self:deselect()
			return true
		end
		self:select()
	end)
	instances.iconButton.MouseButton2Click:Connect(function()
		self._rightClicking = true
		if self:get("dropdownToggleOnRightClick") == true then
			self:_update("dropdownSize")
		end
		if self:get("menuToggleOnRightClick") == true then
			self:_update("menuSize")
		end
		self._rightClicking = false
	end)

	-- Shows/hides the dark overlay when the icon is presssed/released
	instances.iconButton.MouseButton1Down:Connect(function()
		if self.locked then return end
		self:_updateStateOverlay(0.7, Color3.new(0, 0, 0))
	end)
	instances.iconButton.MouseButton1Up:Connect(function()
		if self.locked then return end
		self:_updateStateOverlay(0.9, Color3.new(1, 1, 1))
	end)

	-- Tap away + KeyCode toggles
	userInputService.InputBegan:Connect(function(input, touchingAnObject)
		local validTapAwayInputs = {
			[Enum.UserInputType.MouseButton1] = true,
			[Enum.UserInputType.MouseButton2] = true,
			[Enum.UserInputType.MouseButton3] = true,
			[Enum.UserInputType.Touch] = true,
		}
		if not touchingAnObject and validTapAwayInputs[input.UserInputType] then
			self._tappingAway = true
			if self.dropdownOpen and self:get("dropdownCloseOnTapAway") == true then
				self:_update("dropdownSize")
			end
			if self.menuOpen and self:get("menuCloseOnTapAway") == true then
				self:_update("menuSize")
			end
			self._tappingAway = false
		end
		--
		if self._bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			if self.isSelected then
				self:deselect()
			else
				self:select()
			end
		end
		--
	end)
	
	-- hoverStarted and hoverEnded triggers and actions
	-- these are triggered when a mouse enters/leaves the icon with a mouse, is highlighted with
	-- a controller selection box, or dragged over with a touchpad
	self.hoverStarted:Connect(function(x, y)
		self.hovering = true
		if not self.locked then
			self:_updateStateOverlay(0.9, Color3.fromRGB(255, 255, 255))
		end
		self:_updateHovering()
	end)
	self.hoverEnded:Connect(function()
		self.hovering = false
		self:_updateStateOverlay(1)
		self._hoveringMaid:clean()
		self:_updateHovering()
	end)
	instances.iconButton.MouseEnter:Connect(function(x, y) -- Mouse (started)
		self.hoverStarted:Fire(x, y)
	end)
	instances.iconButton.MouseLeave:Connect(function() -- Mouse (ended)
		self.hoverEnded:Fire()
	end)
	instances.iconButton.SelectionGained:Connect(function() -- Controller (started)
		self.hoverStarted:Fire()
	end)
	instances.iconButton.SelectionLost:Connect(function() -- Controller (ended)
		self.hoverEnded:Fire()
	end)
	instances.iconButton.MouseButton1Down:Connect(function() -- TouchPad (started)
		if self._draggingFinger then
			self.hoverStarted:Fire()
		end
		-- Long press check
		local heartbeatConnection
		local releaseConnection
		local longPressTime = 0.7
		local endTick = tick() + longPressTime
		heartbeatConnection = runService.Heartbeat:Connect(function()
			if tick() >= endTick then
				releaseConnection:Disconnect()
				heartbeatConnection:Disconnect()
				self._longPressing = true
				if self:get("dropdownToggleOnLongPress") == true then
					self:_update("dropdownSize")
				end
				if self:get("menuToggleOnLongPress") == true then
					self:_update("menuSize")
				end
				self._longPressing = false
			end
		end)
		releaseConnection = instances.iconButton.MouseButton1Up:Connect(function()
			releaseConnection:Disconnect()
			heartbeatConnection:Disconnect()
		end)
	end)
	if userInputService.TouchEnabled then
		instances.iconButton.MouseButton1Up:Connect(function() -- TouchPad (ended), this was originally enabled for non-touchpads too
			if self.hovering then
				self.hoverEnded:Fire()
			end
		end)
		-- This is used to highlight when a mobile/touch device is dragging their finger accross the screen
		-- this is important for determining the hoverStarted and hoverEnded events on mobile
		local dragCount = 0
		userInputService.TouchMoved:Connect(function(touch, touchingAnObject)
			if touchingAnObject then
				return
			end
			self._draggingFinger = true
		end)
		userInputService.TouchEnded:Connect(function()
			self._draggingFinger = false
		end)
	end

	-- Finish
	self._updatingIconSize = false
	self:_updateIconSize()
	IconController.iconAdded:Fire(self)
	
	return self
end

-- This is the same as Icon.new(), except it adds additional behaviour for certain specified names designed to mimic core icons, such as 'Chat'
function Icon.mimic(coreIconToMimic)
	local iconName = coreIconToMimic.."Mimic"
	local icon = IconController.getIcon(iconName)
	if icon then
		return icon
	end
	icon = Icon.new()
	icon:setName(iconName)

	if coreIconToMimic == "Chat" then
		icon:setOrder(-1)
		icon:setImage("rbxasset://textures/ui/TopBar/chatOff.png", "deselected")
		icon:setImage("rbxasset://textures/ui/TopBar/chatOn.png", "selected")
		icon:setImageYScale(0.625)
		-- Since roblox's core gui api sucks melons I reverted to listening for signals within the chat modules
		-- unfortunately however they've just gone and removed *these* signals therefore 
		-- this mimic chat and similar features are now impossible to recreate accurately, so I'm disabling for now
		-- ill go ahead and post a feature request; fingers crossed we get something by the next decade

		--[[
		-- Setup maid and cleanup actioon
		local maid = icon._maid
		icon._fakeChatMaid = maid:give(Maid.new())
		maid.chatMimicCleanup = function()
			starterGui:SetCoreGuiEnabled("Chat", icon.enabled)
		end
		-- Tap into chat module
		local chatMainModule = players.LocalPlayer.PlayerScripts:WaitForChild("ChatScript").ChatMain
		local ChatMain = require(chatMainModule)
		local function displayChatBar(visibility)
			icon.ignoreVisibilityStateChange = true
			ChatMain.CoreGuiEnabled:fire(visibility)
			ChatMain.IsCoreGuiEnabled = false
			ChatMain:SetVisible(visibility)
			icon.ignoreVisibilityStateChange = nil
		end
		local function setIconEnabled(visibility)
			icon.ignoreVisibilityStateChange = true
			ChatMain.CoreGuiEnabled:fire(visibility)
			icon:setEnabled(visibility)
			starterGui:SetCoreGuiEnabled("Chat", false)
			icon:deselect()
			icon.updated:Fire()
			icon.ignoreVisibilityStateChange = nil
		end
		-- Open chat via Slash key
		icon._fakeChatMaid:give(userInputService.InputEnded:Connect(function(inputObject, gameProcessedEvent)
			if gameProcessedEvent then
				return "Another menu has priority"
			elseif not(inputObject.KeyCode == Enum.KeyCode.Slash or inputObject.KeyCode == Enum.SpecialKey.ChatHotkey) then
				return "No relavent key pressed"
			elseif ChatMain.IsFocused() then
				return "Chat bar already open"
			elseif not icon.enabled then
				return "Icon disabled"
			end
			ChatMain:FocusChatBar(true)
			icon:select()
		end))
		-- ChatActive
		icon._fakeChatMaid:give(ChatMain.VisibilityStateChanged:Connect(function(visibility)
			if not icon.ignoreVisibilityStateChange then
				if visibility == true then
					icon:select()
				else
					icon:deselect()
				end
			end
		end))
		-- Keep when other icons selected
		icon.deselectWhenOtherIconSelected = false
		-- Mimic chat notifications
		icon._fakeChatMaid:give(ChatMain.MessagesChanged:connect(function()
			if ChatMain:GetVisibility() == true then
				return "ChatWindow was open"
			end
			icon:notify(icon.selected)
		end))
		-- Mimic visibility when StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, state) is called
		coroutine.wrap(function()
			runService.Heartbeat:Wait()
			icon._fakeChatMaid:give(ChatMain.CoreGuiEnabled:connect(function(newState)
				if icon.ignoreVisibilityStateChange then
					return "ignoreVisibilityStateChange enabled"
				end
				local topbarEnabled = starterGui:GetCore("TopbarEnabled")
				if topbarEnabled ~= IconController.previousTopbarEnabled then
					return "SetCore was called instead of SetCoreGuiEnabled"
				end
				if not icon.enabled and userInputService:IsKeyDown(Enum.KeyCode.LeftShift) and userInputService:IsKeyDown(Enum.KeyCode.P) then
					icon:setEnabled(true)
				else
					setIconEnabled(newState)
				end
			end))
		end)()
		icon.deselected:Connect(function()
			displayChatBar(false)
		end)
		icon.selected:Connect(function()
			displayChatBar(true)
		end)
		setIconEnabled(starterGui:GetCoreGuiEnabled("Chat"))
		--]]
	end
	return icon
end



-- CORE UTILITY METHODS
function Icon:set(settingName, value, iconState, setAdditional)
	local settingDetail = self._settingsDictionary[settingName]
	assert(settingDetail ~= nil, ("setting '%s' does not exist"):format(settingName))
	if type(iconState) == "string" then
		iconState = iconState:lower()
	end
	local previousValue = self:get(settingName, iconState)

	if iconState == "hovering" then
		-- Apply hovering state if valid
		settingDetail.hoveringValue = value
		if setAdditional ~= "_ignorePrevious" then
			settingDetail.additionalValues["previous_"..iconState] = previousValue
		end
		if type(setAdditional) == "string" then
			settingDetail.additionalValues[setAdditional.."_"..iconState] = previousValue
		end
		self:_update(settingName)

	else
		-- Update the settings value
		local toggleState = iconState
		local settingType = settingDetail.type
		if settingType == "toggleable" then
			local valuesToSet = {}
			if toggleState == "deselected" or toggleState == "selected" then
				table.insert(valuesToSet, toggleState)
			else
				table.insert(valuesToSet, "deselected")
				table.insert(valuesToSet, "selected")
				toggleState = nil
			end
			for i, v in pairs(valuesToSet) do
				settingDetail.values[v] = value
				if setAdditional ~= "_ignorePrevious" then
					settingDetail.additionalValues["previous_"..v] = previousValue
				end
				if type(setAdditional) == "string" then
					settingDetail.additionalValues[setAdditional.."_"..v] = previousValue
				end
			end
		else
			settingDetail.value = value
			if type(setAdditional) == "string" then
				if setAdditional ~= "_ignorePrevious" then
					settingDetail.additionalValues["previous"] = previousValue
				end
				settingDetail.additionalValues[setAdditional] = previousValue
			end
		end

		-- Check previous and new are not the same
		if previousValue == value then
			return self, "Value was already set"
		end

		-- Update appearances of associated instances
		local currentToggleState = self:getToggleState()
		if not self._updateAfterSettingAll and settingDetail.instanceNames and (currentToggleState == toggleState or toggleState == nil) then
			local ignoreTweenAction = (settingName == "iconSize" and previousValue and previousValue.X.Scale == 1)
			local tweenInfo = (settingDetail.tweenAction and not ignoreTweenAction and self:get(settingDetail.tweenAction)) or TweenInfo.new(0)
			self:_update(settingName, currentToggleState, tweenInfo)
		end
	end

	-- Call any methods present
	if settingDetail.callMethods then
		for _, callMethod in pairs(settingDetail.callMethods) do
			callMethod(self, value, iconState)
		end
	end
	
	-- Call any signals present
	if settingDetail.callSignals then
		for _, callSignal in pairs(settingDetail.callSignals) do
			callSignal:Fire()
		end
	end
	return self
end

function Icon:setAdditionalValue(settingName, setAdditional, value, iconState)
	local settingDetail = self._settingsDictionary[settingName]
	assert(settingDetail ~= nil, ("setting '%s' does not exist"):format(settingName))
	local stringMatch = setAdditional.."_"
	if iconState then
		stringMatch = stringMatch..iconState
	end
	for key, _ in pairs(settingDetail.additionalValues) do
		if string.match(key, stringMatch) then
			settingDetail.additionalValues[key] = value
		end
	end
end

function Icon:get(settingName, iconState, getAdditional)
	local settingDetail = self._settingsDictionary[settingName]
	assert(settingDetail ~= nil, ("setting '%s' does not exist"):format(settingName))
	local valueToReturn, additionalValueToReturn
	if typeof(iconState) == "string" then
		iconState = iconState:lower()
	end

	--if ((self.hovering and settingDetail.hoveringValue) or iconState == "hovering") and getAdditional == nil then
	if (iconState == "hovering") and getAdditional == nil then
		valueToReturn = settingDetail.hoveringValue
		additionalValueToReturn = type(getAdditional) == "string" and settingDetail.additionalValues[getAdditional.."_"..iconState]
	end

	local settingType = settingDetail.type
	if settingType == "toggleable" then
		local toggleState = ((iconState == "deselected" or iconState == "selected") and iconState) or self:getToggleState()
		if additionalValueToReturn == nil then
			additionalValueToReturn = type(getAdditional) == "string" and settingDetail.additionalValues[getAdditional.."_"..toggleState]
		end
		if valueToReturn == nil then
			valueToReturn = settingDetail.values[toggleState]
		end
	
	else
		if additionalValueToReturn == nil then
			additionalValueToReturn = type(getAdditional) == "string" and settingDetail.additionalValues[getAdditional]
		end
		if valueToReturn == nil then
			valueToReturn = settingDetail.value
		end
	end

	return valueToReturn, additionalValueToReturn
end

function Icon:getHovering(settingName)
	local settingDetail = self._settingsDictionary[settingName]
	assert(settingDetail ~= nil, ("setting '%s' does not exist"):format(settingName))
	return settingDetail.hoveringValue
end

function Icon:getToggleState(isSelected)
	isSelected = isSelected or self.isSelected
	return (isSelected and "selected") or "deselected"
end

function Icon:getIconState()
	if self.hovering then
		return "hovering"
	else
		return self:getToggleState()
	end
end

function Icon:_update(settingName, toggleState, customTweenInfo)
	local settingDetail = self._settingsDictionary[settingName]
	assert(settingDetail ~= nil, ("setting '%s' does not exist"):format(settingName))
	toggleState = toggleState or self:getToggleState()
	local value = settingDetail.value or (settingDetail.values and settingDetail.values[toggleState])
	if self.hovering and settingDetail.hoveringValue then
		value = settingDetail.hoveringValue
	end
	if value == nil then return end
	local tweenInfo = customTweenInfo or (settingDetail.tweenAction and settingDetail.tweenAction ~= "" and self:get(settingDetail.tweenAction)) or self:get("toggleTransitionInfo") or TweenInfo.new(0.15)
	local propertyName = settingDetail.propertyName
	local invalidPropertiesTypes = {
		["string"] = true,
		["NumberSequence"] = true,
		["Text"] = true,
		["EnumItem"] = true,
		["ColorSequence"] = true,
	}
	local uniqueSetting = self._uniqueSettingsDictionary[settingName]
	local newValue = value
	if settingDetail.useForcedGroupValue then
		newValue = settingDetail.forcedGroupValue
	end
	if settingDetail.instanceNames then
		for _, instanceName in pairs(settingDetail.instanceNames) do
			local instance = self.instances[instanceName]
			local propertyType = typeof(instance[propertyName])
			local cannotTweenProperty = invalidPropertiesTypes[propertyType] or typeof(instance) == "table"
			if uniqueSetting then
				uniqueSetting(settingName, instance, propertyName, newValue)
			elseif cannotTweenProperty then
				instance[propertyName] = value
			else
				tweenService:Create(instance, tweenInfo, {[propertyName] = newValue}):Play()
			end
			--
			if settingName == "iconSize" and instance[propertyName] ~= newValue then
				self.updated:Fire()
			end
			--
		end
	end
end

function Icon:_updateAll(iconState, customTweenInfo)
	for settingName, settingDetail in pairs(self._settingsDictionary) do
		if settingDetail.instanceNames then
			self:_update(settingName, iconState, customTweenInfo)
		end
	end
end

function Icon:_updateHovering(customTweenInfo)
	for settingName, settingDetail in pairs(self._settingsDictionary) do
		if settingDetail.instanceNames and settingDetail.hoveringValue ~= nil then
			self:_update(settingName, nil, customTweenInfo)
		end
	end
end

function Icon:_updateStateOverlay(transparency, color)
	local stateOverlay = self.instances.iconOverlay
	stateOverlay.BackgroundTransparency = transparency or 1
	stateOverlay.BackgroundColor3 = color or Color3.new(1, 1, 1)
end

function Icon:setTheme(theme, updateAfterSettingAll)
	self._updateAfterSettingAll = updateAfterSettingAll
	for settingsType, settingsDetails in pairs(theme) do
		if settingsType == "toggleable" then
			for settingName, settingValue in pairs(settingsDetails.deselected) do
				if not self.lockedSettings[settingName] then
					self:set(settingName, settingValue, "both")
				end
			end
			for settingName, settingValue in pairs(settingsDetails.selected) do
				if not self.lockedSettings[settingName] then
					self:set(settingName, settingValue, "selected")
				end
			end
		else
			for settingName, settingValue in pairs(settingsDetails) do
				if not self.lockedSettings[settingName] then
					local settingDetail = self._settingsDictionary[settingName]
					if settingsType == "action" and settingDetail == nil then
						settingDetail = {}
						self._settingsDictionary[settingName] = {}
					end
					self:set(settingName, settingValue)
				end
			end
		end
	end
	self._updateAfterSettingAll = nil
	if updateAfterSettingAll then
		self:_updateAll()
	end
	return self
end

function Icon:getInstance(instanceName)
	return self.instances[instanceName]
end

function Icon:setInstance(instanceName, instance)
	local originalInstance = self.instances[instanceName]
	self.instances[instanceName] = instance
	if originalInstance then
		originalInstance:Destroy()
	end
	return self
end

function Icon:getSettingDetail(targetSettingName)
	for _, settingsDetails in pairs(self._settings) do
		for settingName, settingDetail in pairs(settingsDetails) do
			if settingName == targetSettingName then
				return settingDetail
			end
		end
	end
	return false
end

function Icon:modifySetting(settingName, dictionary)
	local settingDetail = self:getSettingDetail(settingName)
	for key, value in pairs(dictionary) do
		settingDetail[key] = value
	end
	return self
end

function Icon:convertLabelToNumberSpinner(numberSpinner)
	-- This updates the number spinners appearance
	self:set("iconLabelSize", UDim2.new(1,0,1,0))
	numberSpinner.Parent = self:getInstance("iconButton")

	-- This creates a fake iconLabel which updates the property of all descendant spinner TextLabels when indexed
	local textLabel = {}
	setmetatable(textLabel, {__newindex = function(_, index, value)
		for _, label in pairs(numberSpinner.Frame:GetDescendants()) do
			if label:IsA("TextLabel") then
				label[index] = value
			end
		end
	end})

	-- This overrides existing instances and settings so that they update the spinners properties (instead of the old textlabel)
	local iconButton = self:getInstance("iconButton")
	iconButton.ZIndex = 0
	self:setInstance("iconLabel", textLabel)
	self:modifySetting("iconText", {instanceNames = {}}) -- We do this to prevent text being modified within the metatable above
	self:setInstance("iconLabelSpinner", numberSpinner.Frame)
	local settingsToConvert = {"iconLabelVisible", "iconLabelAnchorPoint", "iconLabelPosition", "iconLabelSize"}
	for _, settingName in pairs(settingsToConvert) do
		self:modifySetting(settingName, {instanceNames = {"iconLabelSpinner"}})
	end

	-- This applies all the values we just updated
	self:_updateAll()
	return self
end

function Icon:setEnabled(bool)
	self.enabled = bool
	self.instances.iconContainer.Visible = bool
	self.updated:Fire()
	return self
end

function Icon:setName(string)
	self.name = string
	self.instances.iconContainer.Name = string
	return self
end

function Icon:setProperty(propertyName, value)
	self[propertyName] = value
	return self
end

function Icon:_playClickSound()
	local clickSound = self.instances.clickSound
	if clickSound.SoundId ~= nil and #clickSound.SoundId > 0 and clickSound.Volume > 0 then
		local clickSoundCopy = clickSound:Clone()
		clickSoundCopy.Parent = clickSound.Parent
		clickSoundCopy:Play()
		debris:AddItem(clickSoundCopy, clickSound.TimeLength)
	end
end

function Icon:select(byIcon)
	if self.locked then return self end
	self.isSelected = true
	self:_setToggleItemsVisible(true, byIcon)
	self:_updateNotice()
	self:_updateAll()
	self:_playClickSound()
	if #self.dropdownIcons > 0 or #self.menuIcons > 0 then
		IconController:_updateSelectionGroup()
	end
    self.selected:Fire()
    self.toggled:Fire(self.isSelected)
	return self
end

function Icon:deselect(byIcon)
	if self.locked then return self end
	self.isSelected = false
	self:_setToggleItemsVisible(false, byIcon)
	self:_updateNotice()
	self:_updateAll()
	self:_playClickSound()
	if #self.dropdownIcons > 0 or #self.menuIcons > 0 then
		IconController:_updateSelectionGroup()
	end
    self.deselected:Fire()
    self.toggled:Fire(self.isSelected)
	return self
end

function Icon:notify(clearNoticeEvent, noticeId)
	coroutine.wrap(function()
		if not clearNoticeEvent then
			clearNoticeEvent = self.deselected
		end
		if self._parentIcon then
			self._parentIcon:notify(clearNoticeEvent)
		end
		
		local notifComplete = Signal.new()
		local endEvent = self._endNotices:Connect(function()
			notifComplete:Fire()
		end)
		local customEvent = clearNoticeEvent:Connect(function()
			notifComplete:Fire()
		end)
		
		noticeId = noticeId or httpService:GenerateGUID(true)
		self.notices[noticeId] = {
			completeSignal = notifComplete,
			clearNoticeEvent = clearNoticeEvent,
		}
		self.totalNotices += 1
		self:_updateNotice()

		self.notified:Fire(noticeId)
		notifComplete:Wait()
		
		endEvent:Disconnect()
		customEvent:Disconnect()
		notifComplete:Disconnect()
		
		self.totalNotices -= 1
		self.notices[noticeId] = nil
		self:_updateNotice()
	end)()
	return self
end

function Icon:_updateNotice()
	local enabled = true
	if self.totalNotices &lt; 1 then
		enabled = false
	end
	-- Deselect
	if not self.isSelected then
		if (#self.dropdownIcons > 0 or #self.menuIcons > 0) and self.totalNotices > 0 then
			enabled = true
		end
	end
	-- Select
	if self.isSelected then
		if #self.dropdownIcons > 0 or #self.menuIcons > 0 then
			enabled = false
		end
	end
	local value = (enabled and 0) or 1
	self:set("noticeImageTransparency", value)
	self:set("noticeTextTransparency", value)
	self.instances.noticeLabel.Text = (self.totalNotices &lt; 100 and self.totalNotices) or "99+"
end

function Icon:clearNotices()
	self._endNotices:Fire()
	return self
end

function Icon:disableStateOverlay(bool)
	if bool == nil then
		bool = true
	end
	local stateOverlay = self.instances.iconOverlay
	stateOverlay.Visible = not bool
	return self
end



-- TOGGLEABLE METHODS
function Icon:setLabel(text, iconState)
	text = text or ""
	self:set("iconText", text, iconState)
	return self
end

function Icon:setCornerRadius(scale, offset, iconState)
	local oldCornerRadius = self.instances.iconCorner.CornerRadius
	local newCornerRadius = UDim.new(scale or oldCornerRadius.Scale, offset or oldCornerRadius.Offset)
	self:set("iconCornerRadius", newCornerRadius, iconState)
	return self
end

function Icon:setImage(imageId, iconState)
	local textureId = (tonumber(imageId) and "http://www.roblox.com/asset/?id="..imageId) or imageId or ""
	return self:set("iconImage", textureId, iconState)
end

function Icon:setOrder(order, iconState)
	local newOrder = tonumber(order) or 1
	return self:set("order", newOrder, iconState)
end

function Icon:setLeft(iconState)
	return self:set("alignment", "left", iconState)
end

function Icon:setMid(iconState)
	return self:set("alignment", "mid", iconState)
end

function Icon:setRight(iconState)
	if not self.internalIcon then
		IconController.setupHealthbar()
	end
	return self:set("alignment", "right", iconState)
end

function Icon:setImageYScale(YScale, iconState)
	local newYScale = tonumber(YScale) or 0.63
	return self:set("iconImageYScale", newYScale, iconState)
end

function Icon:setImageRatio(ratio, iconState)
	local newRatio = tonumber(ratio) or 1
	return self:set("iconImageRatio", newRatio, iconState)
end

function Icon:setLabelYScale(YScale, iconState)
	local newYScale = tonumber(YScale) or 0.45
	return self:set("iconLabelYScale", newYScale, iconState)
end
	
function Icon:setBaseZIndex(ZIndex, iconState)
	local newBaseZIndex = tonumber(ZIndex) or 1
	return self:set("baseZIndex", newBaseZIndex, iconState)
end

function Icon:_updateBaseZIndex(baseValue)
	local container = self.instances.iconContainer
	local newBaseValue = tonumber(baseValue) or container.ZIndex
	local difference = newBaseValue - container.ZIndex
	if difference == 0 then return "The baseValue is the same" end
	for _, object in pairs(self.instances) do
		object.ZIndex = object.ZIndex + difference
	end
	return true
end

function Icon:setSize(XOffset, YOffset, iconState)
	local newXOffset = tonumber(XOffset) or 32
	local newYOffset = tonumber(YOffset) or newXOffset
	self:set("forcedIconSize", UDim2.new(0, newXOffset, 0, newYOffset), iconState)
	self:set("iconSize", UDim2.new(0, newXOffset, 0, newYOffset), iconState)
	return self
end

function Icon:_updateIconSize(_, iconState)
	if self._destroyed then return end
	-- This is responsible for handling the appearance and size of the icons label and image, in additon to its own size
	local X_MARGIN = 12
	local X_GAP = 8

	local values = {
		iconImage = self:get("iconImage", iconState) or "_NIL",
		iconText = self:get("iconText", iconState) or "_NIL",
		iconFont = self:get("iconFont", iconState) or "_NIL",
		iconSize = self:get("iconSize", iconState) or "_NIL",
		forcedIconSize = self:get("forcedIconSize", iconState) or "_NIL",
		iconImageYScale = self:get("iconImageYScale", iconState) or "_NIL",
		iconImageRatio = self:get("iconImageRatio", iconState) or "_NIL",
		iconLabelYScale = self:get("iconLabelYScale", iconState) or "_NIL",
	}
	for k,v in pairs(values) do
		if v == "_NIL" then
			return
		end
	end

	local iconContainer = self.instances.iconContainer
	if not iconContainer.Parent then return end

	-- We calculate the cells dimensions as apposed to reading because there's a possibility the cells dimensions were changed at the exact time and have not yet updated
	-- this essentially saves us from waiting a heartbeat which causes additonal complications
	local cellSizeXOffset = values.iconSize.X.Offset
	local cellSizeXScale = values.iconSize.X.Scale
	local cellWidth = cellSizeXOffset + (cellSizeXScale * iconContainer.Parent.AbsoluteSize.X)
	local minCellWidth = values.forcedIconSize.X.Offset--cellWidth
	local maxCellWidth = (cellSizeXScale > 0 and cellWidth) or 9999
	local cellSizeYOffset = values.iconSize.Y.Offset
	local cellSizeYScale = values.iconSize.Y.Scale
	local cellHeight = cellSizeYOffset + (cellSizeYScale * iconContainer.Parent.AbsoluteSize.Y)
	local labelHeight = cellHeight * values.iconLabelYScale
	local labelWidth = textService:GetTextSize(values.iconText, labelHeight, values.iconFont, Vector2.new(10000, labelHeight)).X
	local imageWidth = cellHeight * values.iconImageYScale * values.iconImageRatio
	
	local usingImage = values.iconImage ~= ""
	local usingText = values.iconText ~= ""
	local notifPosYScale = 0.5
	local desiredCellWidth
	local preventClippingOffset = labelHeight/2
	
	if usingImage and not usingText then
		notifPosYScale = 0.45
		self:set("iconImageVisible", true, iconState)
		self:set("iconImageAnchorPoint", Vector2.new(0.5, 0.5), iconState)
		self:set("iconImagePosition", UDim2.new(0.5, 0, 0.5, 0), iconState)
		self:set("iconImageSize", UDim2.new(values.iconImageYScale*values.iconImageRatio, 0, values.iconImageYScale, 0), iconState)
		self:set("iconLabelVisible", false, iconState)

	elseif not usingImage and usingText then
		desiredCellWidth = labelWidth+(X_MARGIN*2)
		self:set("iconLabelVisible", true, iconState)
		self:set("iconLabelAnchorPoint", Vector2.new(0, 0.5), iconState)
		self:set("iconLabelPosition", UDim2.new(0, X_MARGIN, 0.5, 0), iconState)
		self:set("iconLabelSize", UDim2.new(1, -X_MARGIN*2, values.iconLabelYScale, preventClippingOffset), iconState)
		self:set("iconLabelTextXAlignment", Enum.TextXAlignment.Center, iconState)
		self:set("iconImageVisible", false, iconState)

	elseif usingImage and usingText then
		local labelGap = X_MARGIN + imageWidth + X_GAP
		desiredCellWidth = labelGap + labelWidth + X_MARGIN
		self:set("iconImageVisible", true, iconState)
		self:set("iconImageAnchorPoint", Vector2.new(0, 0.5), iconState)
		self:set("iconImagePosition", UDim2.new(0, X_MARGIN, 0.5, 0), iconState)
		self:set("iconImageSize", UDim2.new(0, imageWidth, values.iconImageYScale, 0), iconState)
		----
		self:set("iconLabelVisible", true, iconState)
		self:set("iconLabelAnchorPoint", Vector2.new(0, 0.5), iconState)
		self:set("iconLabelPosition", UDim2.new(0, labelGap, 0.5, 0), iconState)
		self:set("iconLabelSize", UDim2.new(1, -labelGap-X_MARGIN, values.iconLabelYScale, preventClippingOffset), iconState)
		self:set("iconLabelTextXAlignment", Enum.TextXAlignment.Left, iconState)
	end
	if desiredCellWidth then
		if not self._updatingIconSize then
			self._updatingIconSize = true
			local widthScale = (cellSizeXScale > 0 and cellSizeXScale) or 0
			local widthOffset = (cellSizeXScale > 0 and 0) or math.clamp(desiredCellWidth, minCellWidth, maxCellWidth)
			self:set("iconSize", UDim2.new(widthScale, widthOffset, values.iconSize.Y.Scale, values.iconSize.Y.Offset), iconState, "_ignorePrevious")

			-- This ensures that if an icon is within a dropdown or menu, its container adapts accordingly with this new iconSize value
			local parentIcon = self._parentIcon
			if parentIcon then
				local originalIconSize = UDim2.new(0, desiredCellWidth, 0, values.iconSize.Y.Offset)
				if #parentIcon.dropdownIcons > 0 then
					self:setAdditionalValue("iconSize", "beforeDropdown", originalIconSize, iconState)
					parentIcon:_updateDropdown()
				end
				if #parentIcon.menuIcons > 0 then
					self:setAdditionalValue("iconSize", "beforeMenu", originalIconSize, iconState)
					parentIcon:_updateMenu()
				end
			end

			self._updatingIconSize = false
		end
	end
	self:set("iconLabelTextSize", labelHeight, iconState)
	self:set("noticeFramePosition", UDim2.new(notifPosYScale, 0, 0, -2), iconState)

	self._updatingIconSize = false
end



-- FEATURE METHODS
function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self._bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self._bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self._bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self._bindedToggleKeys[keyCodeEnum] = true
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self._bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:lock()
	self.locked = true
	return self
end

function Icon:unlock()
	self.locked = false
	return self
end

function Icon:setTopPadding(offset, scale)
	local newOffset = offset or 4
	local newScale = scale or 0
	self.topPadding = UDim.new(newScale, newOffset)
	self.updated:Fire()
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	return self
end

function Icon:_setToggleItemsVisible(bool, byIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not byIcon or byIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:give(userdata)
	local valueToGive = userdata
	if typeof(userdata) == "function" then
		local returnValue = userdata(self)
		if typeof(userdata) ~= "function" then
			valueToGive = returnValue
		else
			valueToGive = nil
		end
	end
	if valueToGive ~= nil then
		self._maid:give(valueToGive)
	end
	return self
end

-- Tips
DEFAULT_FORCED_GROUP_VALUES["tip"] = 1

function Icon:setTip(text)
	assert(typeof(text) == "string" or text == nil, "Expected string, got "..typeof(text))
	local realText = text or ""
	local isVisible = realText ~= ""
	local textSize = textService:GetTextSize(realText, 12, Enum.Font.GothamSemibold, Vector2.new(1000, 20-6))
	self.instances.tipLabel.Text = realText
	self.instances.tipFrame.Size = (isVisible and UDim2.new(0, textSize.X+6, 0, 20)) or UDim2.new(0, 0, 0, 0)
	self.instances.tipFrame.Parent = (isVisible and activeItems) or self.instances.iconContainer
	self._maid.tipFrame = self.instances.tipFrame
	self.tipText = text
	
	local tipMaid = Maid.new()
	self._maid.tipMaid = tipMaid
	if isVisible then
		tipMaid:give(self.hoverStarted:Connect(function()
			if not self.isSelected then
				self:displayTip(true)
			end
		end))
		tipMaid:give(self.hoverEnded:Connect(function()
			self:displayTip(false)
		end))
		tipMaid:give(self.selected:Connect(function()
			if self.hovering then
				self:displayTip(false)
			end
		end))
	end
	self:displayTip(self.hovering and isVisible)
	return self
end

function Icon:displayTip(bool)
	if userInputService.TouchEnabled and not self._draggingFinger then return end

	-- Determine caption visibility
	local isVisible = self.tipVisible or false
	if typeof(bool) == "boolean" then
		isVisible = bool
	end
	self.tipVisible = isVisible

	-- Have tip position track mouse or finger
	local tipFrame = self.instances.tipFrame
	if isVisible then
		-- When the user moves their cursor/finger, update tip to match the position
		local function updateTipPositon(x, y)
			local newX = x
			local newY = y
			local camera = workspace.CurrentCamera
			local viewportSize = camera and camera.ViewportSize
			if userInputService.TouchEnabled then
				--tipFrame.AnchorPoint = Vector2.new(0.5, 0.5)
				local desiredX = newX - tipFrame.Size.X.Offset/2
				local minX = 0
				local maxX = viewportSize.X - tipFrame.Size.X.Offset
				local desiredY = newY + THUMB_OFFSET + 60
				local minY = tipFrame.AbsoluteSize.Y + THUMB_OFFSET + 64 + 3
				local maxY = viewportSize.Y - tipFrame.Size.Y.Offset
				newX = math.clamp(desiredX, minX, maxX)
				newY = math.clamp(desiredY, minY, maxY)
			elseif IconController.controllerModeEnabled then
				local indicator = TopbarPlusGui.Indicator
				local newPos = indicator.AbsolutePosition
				newX = newPos.X - tipFrame.Size.X.Offset/2 + indicator.AbsoluteSize.X/2
				newY = newPos.Y + 90
			else
				local desiredX = newX
				local minX = 0
				local maxX = viewportSize.X - tipFrame.Size.X.Offset - 48
				local desiredY = newY
				local minY = tipFrame.Size.Y.Offset+3
				local maxY = viewportSize.Y
				newX = math.clamp(desiredX, minX, maxX)
				newY = math.clamp(desiredY, minY, maxY)
			end
			--local difX = tipFrame.AbsolutePosition.X - tipFrame.Position.X.Offset
			--local difY = tipFrame.AbsolutePosition.Y - tipFrame.Position.Y.Offset
			--local globalX = newX - difX
			--local globalY = newY - difY
			--tipFrame.Position = UDim2.new(0, globalX, 0, globalY-55)
			tipFrame.Position = UDim2.new(0, newX, 0, newY-20)
		end
		local cursorLocation = userInputService:GetMouseLocation()
		if cursorLocation then
			updateTipPositon(cursorLocation.X, cursorLocation.Y)
		end
		self._hoveringMaid:give(self.instances.iconButton.MouseMoved:Connect(updateTipPositon))
	end

	-- Change transparency of relavent tip instances
	for _, settingName in pairs(self._groupSettings.tip) do
		local settingDetail = self._settingsDictionary[settingName]
		settingDetail.useForcedGroupValue = not isVisible
		self:_update(settingName)
	end
end

-- Captions
DEFAULT_FORCED_GROUP_VALUES["caption"] = 1

function Icon:setCaption(text)
	assert(typeof(text) == "string" or text == nil, "Expected string, got "..typeof(text))
	local realText = text or ""
	local isVisible = realText ~= ""
	self.captionText = text
	self.instances.captionLabel.Text = realText
	self.instances.captionContainer.Parent = (isVisible and activeItems) or self.instances.iconContainer
	self._maid.captionContainer = self.instances.captionContainer
	self:_updateIconSize(nil, self:getIconState())
	local captionMaid = Maid.new()
	self._maid.captionMaid = captionMaid
	if isVisible then
		captionMaid:give(self.hoverStarted:Connect(function()
			if not self.isSelected then
				self:displayCaption(true)
			end
		end))
		captionMaid:give(self.hoverEnded:Connect(function()
			self:displayCaption(false)
		end))
		captionMaid:give(self.selected:Connect(function()
			if self.hovering then
				self:displayCaption(false)
			end
		end))
		local iconContainer = self.instances.iconContainer
		captionMaid:give(iconContainer:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			if self.hovering then
				self:displayCaption()
			end
		end))
		captionMaid:give(iconContainer:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
			if self.hovering then
				self:displayCaption()
			end
		end))
	end

	-- This adapts the caption size
	local CAPTION_X_MARGIN = 6
	local CAPTION_CONTAINER_Y_SIZE_SCALE = 0.8
	local CAPTION_LABEL_Y_SCALE = 0.58
	local iconSize = self:get("iconSize")
	local labelFont = self:get("captionFont")
	if iconSize and labelFont then
		local cellSizeYOffset = iconSize.Y.Offset
		local cellSizeYScale = iconSize.Y.Scale
		local iconContainer = self.instances.iconContainer
		local captionContainer = self.instances.captionContainer
		if isVisible then
			local cellHeight = cellSizeYOffset + (cellSizeYScale * iconContainer.Parent.AbsoluteSize.Y)
			local captionLabel = self.instances.captionLabel
			local captionContainerHeight = cellHeight * CAPTION_CONTAINER_Y_SIZE_SCALE
			local captionLabelHeight = captionContainerHeight * CAPTION_LABEL_Y_SCALE
			local textWidth = textService:GetTextSize(self.captionText, captionLabelHeight, labelFont, Vector2.new(10000, captionLabelHeight)).X
			captionLabel.TextSize = captionLabelHeight
			captionLabel.Size = UDim2.new(0, textWidth, CAPTION_LABEL_Y_SCALE, 0)
			captionContainer.Size = UDim2.new(0, textWidth + CAPTION_X_MARGIN*2, 0, cellHeight*CAPTION_CONTAINER_Y_SIZE_SCALE)
		else
			captionContainer.Size = UDim2.new(0, 0, 0, 0)
		end
	end

	self:displayCaption(self.hovering and isVisible)
	return self
end

function Icon:displayCaption(bool)
	if userInputService.TouchEnabled and not self._draggingFinger then return end
	local yOffset = 8
	
	-- Determine caption position
	if self._draggingFinger then
		yOffset = yOffset + THUMB_OFFSET
	end
	local iconContainer = self.instances.iconContainer
	local captionContainer = self.instances.captionContainer
	local newPos = UDim2.new(0, iconContainer.AbsolutePosition.X+iconContainer.AbsoluteSize.X/2-captionContainer.AbsoluteSize.X/2, 0, iconContainer.AbsolutePosition.Y+(iconContainer.AbsoluteSize.Y*2)+yOffset)
	captionContainer.Position = newPos

	-- Determine caption visibility
	local isVisible = self.captionVisible or false
	if typeof(bool) == "boolean" then
		isVisible = bool
	end
	self.captionVisible = isVisible

	-- Change transparency of relavent caption instances
	local captionFadeInfo = self:get("captionFadeInfo")
	for _, settingName in pairs(self._groupSettings.caption) do
		local settingDetail = self._settingsDictionary[settingName]
		settingDetail.useForcedGroupValue = not isVisible
		self:_update(settingName)
	end
end

-- Join or leave a special feature such as a Dropdown or Menu
function Icon:join(parentIcon, featureName, dontUpdate)
	if self._parentIcon then
		self:leave()
	end
	local newFeatureName = (featureName and featureName:lower()) or "dropdown"
	local beforeName = "before"..featureName:sub(1,1):upper()..featureName:sub(2)
	local parentFrame = parentIcon.instances[featureName.."Frame"]
	self.presentOnTopbar = false
	self.joinedFeatureName = featureName
	self._parentIcon = parentIcon
	self.instances.iconContainer.Parent = parentFrame
	for noticeId, noticeDetail in pairs(self.notices) do
		parentIcon:notify(noticeDetail.clearNoticeEvent, noticeId)
		--parentIcon:notify(noticeDetail.completeSignal, noticeId)
	end
	
	if featureName == "dropdown" then
		local squareCorners = parentIcon:get("dropdownSquareCorners")
		self:set("iconSize", UDim2.new(1, 0, 0, self:get("iconSize", "deselected").Y.Offset), "deselected", beforeName)
		self:set("iconSize", UDim2.new(1, 0, 0, self:get("iconSize", "selected").Y.Offset), "selected", beforeName)
		if squareCorners then
			self:set("iconCornerRadius", UDim.new(0, 0), "deselected", beforeName)
			self:set("iconCornerRadius", UDim.new(0, 0), "selected", beforeName)
		end
		self:set("captionBlockerTransparency", 0.4, nil, beforeName)
	end
	local array = parentIcon[newFeatureName.."Icons"]
	table.insert(array, self)
	if not dontUpdate then
		parentIcon:_updateDropdown()
	end
	parentIcon.deselectWhenOtherIconSelected = false
	--
	IconController:_updateSelectionGroup()
	self:_decideToCallSignal("dropdown")
	self:_decideToCallSignal("menu")
	--
	return self
end

function Icon:leave()
	if self._destroyed or self.instances.iconContainer.Parent == nil then
		return
	end
	local settingsToReset = {"iconSize", "captionBlockerTransparency", "iconCornerRadius"}
	local parentIcon = self._parentIcon
	self.instances.iconContainer.Parent = topbarContainer
	self.presentOnTopbar = true
	self.joinedFeatureName = nil
	local function scanFeature(t, prevReference, updateMethod)
		for i, otherIcon in pairs(t) do
			if otherIcon == self then
				for _, settingName in pairs(settingsToReset) do
					local states = {"deselected", "selected"}
					for _, toggleState in pairs(states) do
						local currentSetting, previousSetting = self:get(settingName, toggleState, prevReference)
						if previousSetting then
							self:set(settingName, previousSetting, toggleState)
						end
					end
				end
				table.remove(t, i)
				updateMethod(parentIcon)
				if #t == 0 then
					self._parentIcon.deselectWhenOtherIconSelected = true
				end
				break
			end
		end
	end
	scanFeature(parentIcon.dropdownIcons, "beforeDropdown", parentIcon._updateDropdown)
	scanFeature(parentIcon.menuIcons, "beforeMenu", parentIcon._updateMenu)
	--
	for noticeId, noticeDetail in pairs(self.notices) do
		local parentIconNoticeDetail = parentIcon.notices[noticeId]
		if parentIconNoticeDetail then
			parentIconNoticeDetail.completeSignal:Fire()
		end
	end
	--
	self._parentIcon = nil
	--
	IconController:_updateSelectionGroup()
	self:_decideToCallSignal("dropdown")
	self:_decideToCallSignal("menu")
	--
	return self
end

function Icon:_decideToCallSignal(featureName)
	local isOpen = self[featureName.."Open"]
	local previousIsOpenName = "_previous"..string.sub(featureName, 1, 1):upper()..featureName:sub(2).."Open"
	local previousIsOpen = self[previousIsOpenName]
	local totalIcons = #self[featureName.."Icons"]
	if isOpen and totalIcons > 0 and previousIsOpen == false then
		self[previousIsOpenName] = true
		self[featureName.."Opened"]:Fire()
	elseif (not isOpen or totalIcons == 0) and previousIsOpen == true then
		self[previousIsOpenName] = false
		self[featureName.."Closed"]:Fire()
	end
end

function Icon:_ignoreClipping(featureName)
	local ignoreClipping = self:get(featureName.."IgnoreClipping")
	if self._parentIcon then
		local maid = self["_"..featureName.."ClippingMaid"]
		local frame = self.instances[featureName.."Container"]
		maid:clean()
		if ignoreClipping then
			local fakeFrame = Instance.new("Frame")
			fakeFrame.Name = frame.Name.."FakeFrame"
			fakeFrame.ClipsDescendants = true
			fakeFrame.BackgroundTransparency = 1
			fakeFrame.Size = frame.Size
			fakeFrame.Position = frame.Position
			fakeFrame.Parent = activeItems
			--
			for a,b in pairs(frame:GetChildren()) do
				b.Parent = fakeFrame
			end
			--
			local function updateSize()
				local absoluteSize = frame.AbsoluteSize
				fakeFrame.Size = UDim2.new(0, absoluteSize.X, 0, absoluteSize.Y)
			end
			maid:give(frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updateSize()
			end))
			updateSize()
			local function updatePos()
				local absolutePosition = frame.absolutePosition
				fakeFrame.Position = UDim2.new(0, absolutePosition.X, 0, absolutePosition.Y+36)
			end
			maid:give(frame:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
				updatePos()
			end))
			updatePos()
			maid:give(function()
				for a,b in pairs(fakeFrame:GetChildren()) do
					b.Parent = frame
				end
				fakeFrame.Name = "Destroying..."
				fakeFrame:Destroy()
			end)
		end
	end
	self._ignoreClippingChanged:Fire(featureName, ignoreClipping)
end

-- Dropdowns
function Icon:setDropdown(arrayOfIcons)
	-- Reset any previous icons
	for i, otherIcon in pairs(self.dropdownIcons) do
		otherIcon:leave()
	end
	-- Apply new icons
	if type(arrayOfIcons) == "table" then
		for i, otherIcon in pairs(arrayOfIcons) do
			otherIcon:join(self, "dropdown", true)
		end
	end
	-- Update dropdown
	self:_updateDropdown()
	return self
end

function Icon:_updateDropdown()
	local values = {
		maxIconsBeforeScroll = self:get("dropdownMaxIconsBeforeScroll") or "_NIL",
		minWidth = self:get("dropdownMinWidth") or "_NIL",
		padding = self:get("dropdownListPadding") or "_NIL",
		dropdownAlignment = self:get("dropdownAlignment") or "_NIL",
		iconAlignment = self:get("alignment") or "_NIL",
		scrollBarThickness = self:get("dropdownScrollBarThickness") or "_NIL",
	}
	for k, v in pairs(values) do if v == "_NIL" then return end end
	
	local YPadding = values.padding.Offset
	local dropdownContainer = self.instances.dropdownContainer
	local dropdownFrame = self.instances.dropdownFrame
	local dropdownList = self.instances.dropdownList
	local totalIcons = #self.dropdownIcons

	local lastVisibleIconIndex = (totalIcons > values.maxIconsBeforeScroll and values.maxIconsBeforeScroll) or totalIcons
	local newCanvasSizeY = -YPadding
	local newFrameSizeY = 0
	local newMinWidth = values.minWidth
	table.sort(self.dropdownIcons, function(a,b) return a:get("order") &lt; b:get("order") end)
	for i = 1, totalIcons do
		local otherIcon = self.dropdownIcons[i]
		local _, otherIconSize = otherIcon:get("iconSize", nil, "beforeDropdown")
		local increment = otherIconSize.Y.Offset + YPadding
		if i &lt;= lastVisibleIconIndex then
			newFrameSizeY = newFrameSizeY + increment
		end
		if i == totalIcons then
			newFrameSizeY = newFrameSizeY + increment/4
		end
		newCanvasSizeY = newCanvasSizeY + increment
		local otherIconWidth = otherIconSize.X.Offset --+ 4 + 100 -- the +100 is to allow for notices
		if otherIconWidth > newMinWidth then
			newMinWidth = otherIconWidth
		end
	end

	local finalCanvasSizeY = (lastVisibleIconIndex == totalIcons and 0) or newCanvasSizeY
	self:set("dropdownCanvasSize", UDim2.new(0, 0, 0, finalCanvasSizeY))
	self:set("dropdownSize", UDim2.new(0, (newMinWidth+4)*2, 0, newFrameSizeY))

	-- Set alignment while considering screen bounds
	local dropdownAlignment = values.dropdownAlignment:lower()
	local alignmentDetails = {
		left = {
			AnchorPoint = Vector2.new(0, 0),
			PositionXScale = 0,
			ThicknessMultiplier = 0,
		},
		mid = {
			AnchorPoint = Vector2.new(0.5, 0),
			PositionXScale = 0.5,
			ThicknessMultiplier = 0.5,
		},
		right = {
			AnchorPoint = Vector2.new(0.5, 0),
			PositionXScale = 1,
			FrameAnchorPoint = Vector2.new(0, 0),
			FramePositionXScale = 0,
			ThicknessMultiplier = 1,
		}
	}
	local alignmentDetail = alignmentDetails[dropdownAlignment]
	if not alignmentDetail then
		alignmentDetail = alignmentDetails[values.iconAlignment:lower()]
	end
	dropdownContainer.AnchorPoint = alignmentDetail.AnchorPoint
	dropdownContainer.Position = UDim2.new(alignmentDetail.PositionXScale, 0, 1, YPadding+0)
	local scrollbarThickness = values.scrollBarThickness
	local newThickness = scrollbarThickness * alignmentDetail.ThicknessMultiplier
	local additionalOffset = (dropdownFrame.VerticalScrollBarPosition == Enum.VerticalScrollBarPosition.Right and newThickness) or -newThickness
	dropdownFrame.AnchorPoint = alignmentDetail.FrameAnchorPoint or alignmentDetail.AnchorPoint
	dropdownFrame.Position = UDim2.new(alignmentDetail.FramePositionXScale or alignmentDetail.PositionXScale, additionalOffset, 0, 0)
	self._dropdownCanvasPos = Vector2.new(0, 0)
end

function Icon:_dropdownIgnoreClipping()
	self:_ignoreClipping("dropdown")
end


-- Menus
function Icon:setMenu(arrayOfIcons)
	-- Reset any previous icons
	for i, otherIcon in pairs(self.menuIcons) do
		otherIcon:leave()
	end
	-- Apply new icons
	if type(arrayOfIcons) == "table" then
		for i, otherIcon in pairs(arrayOfIcons) do
			otherIcon:join(self, "menu", true)
		end
	end
	-- Update menu
	self:_updateMenu()
	return self
end

function Icon:_getMenuDirection()
	local direction = (self:get("menuDirection") or "_NIL"):lower()
	local alignment = (self:get("alignment") or "_NIL"):lower()
	if direction ~= "left" and direction ~= "right" then
		direction = (alignment == "left" and "right") or "left" 
	end
	return direction
end

function Icon:_updateMenu()
	local values = {
		maxIconsBeforeScroll = self:get("menuMaxIconsBeforeScroll") or "_NIL",
		direction = self:get("menuDirection") or "_NIL",
		iconAlignment = self:get("alignment") or "_NIL",
		scrollBarThickness = self:get("menuScrollBarThickness") or "_NIL",
	}
	for k, v in pairs(values) do if v == "_NIL" then return end end
	
	local XPadding = IconController[values.iconAlignment.."Gap"]--12
	local menuContainer = self.instances.menuContainer
	local menuFrame = self.instances.menuFrame
	local menuList = self.instances.menuList
	local totalIcons = #self.menuIcons

	local direction = self:_getMenuDirection()
	local lastVisibleIconIndex = (totalIcons > values.maxIconsBeforeScroll and values.maxIconsBeforeScroll) or totalIcons
	local newCanvasSizeX = -XPadding
	local newFrameSizeX = 0
	local newMinHeight = 0
	local sortFunc = (direction == "right" and function(a,b) return a:get("order") &lt; b:get("order") end) or function(a,b) return a:get("order") > b:get("order") end
	table.sort(self.menuIcons, sortFunc)
	for i = 1, totalIcons do
		local otherIcon = self.menuIcons[i]
		local otherIconSize = otherIcon:get("iconSize")
		local increment = otherIconSize.X.Offset + XPadding
		if i &lt;= lastVisibleIconIndex then
			newFrameSizeX = newFrameSizeX + increment
		end
		if i == lastVisibleIconIndex and i ~= totalIcons then
			newFrameSizeX = newFrameSizeX -2--(increment/4)
		end
		newCanvasSizeX = newCanvasSizeX + increment
		local otherIconHeight = otherIconSize.Y.Offset
		if otherIconHeight > newMinHeight then
			newMinHeight = otherIconHeight
		end
	end

	local canvasSize = (lastVisibleIconIndex == totalIcons and 0) or newCanvasSizeX + XPadding
	self:set("menuCanvasSize", UDim2.new(0, canvasSize, 0, 0))
	self:set("menuSize", UDim2.new(0, newFrameSizeX, 0, newMinHeight + values.scrollBarThickness + 3))

	-- Set direction
	local directionDetails = {
		left = {
			containerAnchorPoint = Vector2.new(1, 0),
			containerPosition = UDim2.new(0, -4, 0, 0),
			canvasPosition = Vector2.new(canvasSize, 0)
		},
		right = {
			containerAnchorPoint = Vector2.new(0, 0),
			containerPosition = UDim2.new(1, XPadding-2, 0, 0),
			canvasPosition = Vector2.new(0, 0),
		}
	}
	local directionDetail = directionDetails[direction]
	menuContainer.AnchorPoint = directionDetail.containerAnchorPoint
	menuContainer.Position = directionDetail.containerPosition
	menuFrame.CanvasPosition = directionDetail.canvasPosition
	self._menuCanvasPos = directionDetail.canvasPosition

	menuList.Padding = UDim.new(0, XPadding)
end

function Icon:_menuIgnoreClipping()
	self:_ignoreClipping("menu")
end



-- DESTROY/CLEANUP METHOD
function Icon:destroy()
	if self._destroyed then return end
	IconController.iconRemoved:Fire(self)
	self:clearNotices()
	if self._parentIcon then
		self:leave()
	end
	self:setDropdown()
	self:setMenu()
	self._destroyed = true
	self._maid:clean()
end
Icon.Destroy = Icon.destroy -- an alias for you maid-using Pascal lovers



return Icon</string>
              </Properties>
              <Item class="ModuleScript" referent="32">
                <Properties>
                  <string name="Name">IconController</string>
                  <string name="Source">--[[ icon_controller:header
## Functions

#### setGameTheme
```lua
IconController.setGameTheme(theme)
```
Sets the default theme which is applied to all existing and future icons.

----
#### setDisplayOrder
```lua
IconController.setDisplayOrder(number)
```
Changes the DisplayOrder of the TopbarPlus ScreenGui to the given value.

----
#### setTopbarEnabled
```lua
IconController.setTopbarEnabled(bool)
```
When set to ``false``, hides all icons created with TopbarPlus. This can also be achieved by calling ``starterGui:SetCore("TopbarEnabled", false)``.

----
#### setGap
```lua
IconController.setGap(integer, alignment)
```
Defines the offset width (i.e. gap) between each icon for the given alignment, ``left``, ``mid``, ``right``, or all alignments if not specified. 

----
#### setLeftOffset
```lua
IconController.setLeftOffset(integer)
```
Defines the offset from the left side of the screen to the nearest left-set icon. 

----
#### setRightOffset
```lua
IconController.setRightOffset(integer)
```
Defines the offset from the right side of the screen to the nearest right-set icon. 

----
#### updateTopbar
```lua
IconController.updateTopbar()
```
Determines how icons should be positioned on the topbar and moves them accordingly.  

----
#### clearIconOnSpawn
```lua
IconController.clearIconOnSpawn(icon)
```
Calls destroy on the given icon when the player respawns. This is useful for scenarious where you wish to cleanup icons that are constructed within a Gui with ``ResetOnSpawn`` set to ``true``. For example:

```lua
-- Place at the bottom of your icon creator localscript
local icons = IconController.getIcons()
for _, icon in pairs(icons) do
	IconController.clearIconOnSpawn(icon)
end
```

----
#### getIcons
```lua
local arrayOfIcons = IconController.getIcons()
```
Returns all icons as an array.

----
#### getIcon
```lua
local icon = IconController.getIcon(name)
```
Returns the icon with the given name (or ``false`` if not found). If multiple icons have the same name, then one will be returned randomly.

----
#### disableHealthbar
```lua
IconController.disableHealthbar(bool)
```
Hides the fake healthbar (if currently visible) and prevents it becoming visible again (which normally occurs when the player takes damage).

----



## Properties
#### mimicCoreGui
```lua
local bool = IconController.mimicCoreGui --[default: 'true']
```
Set to ``false`` to have the topbar persist even when ``game:GetService("StarterGui"):SetCore("TopbarEnabled", false)`` is called.

----
#### controllerModeEnabled
{read-only}
```lua
local bool = IconController.controllerModeEnabled
```

----
#### leftGap
{read-only}
```lua
local gapNumber = IconController.leftGap --[default: '12']
```

----
#### midGap
{read-only}
```lua
local gapNumber = IconController.midGap --[default: '12']
```

----
#### rightGap
{read-only}
```lua
local gapNumber = IconController.rightGap --[default: '12']
```

----
#### leftOffset
{read-only}
```lua
local offset = IconController.leftGap --[default: '0']
```

----
#### rightOffset
{read-only}
```lua
local offset = IconController.rightGap --[default: '0']
```
--]]



-- LOCAL
local starterGui = game:GetService("StarterGui")
local guiService = game:GetService("GuiService")
local hapticService = game:GetService("HapticService")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")
local players = game:GetService("Players")
local IconController = {}
local replicatedStorage = game:GetService("ReplicatedStorage")
local Signal = require(script.Parent.Signal)
local TopbarPlusGui = require(script.Parent.TopbarPlusGui)
local topbarIcons = {}
local fakeChatName = "_FakeChat"
local forceTopbarDisabled = false
local menuOpen
local topbarUpdating = false
local STUPID_CONTROLLER_OFFSET = 32



-- LOCAL FUNCTIONS
local function checkTopbarEnabled()
	local success, bool = xpcall(function()
		return starterGui:GetCore("TopbarEnabled")
	end,function(err)
		--has not been registered yet, but default is that is enabled
		return true	
	end)
	return (success and bool)
end

local function checkTopbarEnabledAccountingForMimic()
	local topbarEnabledAccountingForMimic = (checkTopbarEnabled() or not IconController.mimicCoreGui)
	return topbarEnabledAccountingForMimic
end



-- OFFSET HANDLERS
local alignmentDetails = {}
alignmentDetails["left"] = {
	startScale = 0,
	getOffset = function()
		local offset = 48 + IconController.leftOffset
		if checkTopbarEnabled() and starterGui:GetCoreGuiEnabled("Chat") then
			offset += 12 + 32
		end
		return offset
	end,
	getStartOffset = function()
		local alignmentGap = IconController["leftGap"]
		local startOffset = alignmentDetails.left.getOffset() + alignmentGap
		return startOffset
	end,
	records = {}
}
alignmentDetails["mid"] = {
	startScale = 0.5,
	getOffset = function()
		return 0
	end,
	getStartOffset = function(totalIconX) 
		local alignmentGap = IconController["midGap"]
		return -totalIconX/2 + (alignmentGap/2)
	end,
	records = {}
}
alignmentDetails["right"] = {
	startScale = 1,
	getOffset = function()
		local offset = IconController.rightOffset
		if checkTopbarEnabled() and (starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList) or starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Backpack) or starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu)) then
			offset += 48
		end
		return offset
	end,
	getStartOffset = function(totalIconX)
		local startOffset = -totalIconX - alignmentDetails.right.getOffset()
		return startOffset
	end,
	records = {}
	--reverseSort = true
}



-- PROPERTIES
IconController.topbarEnabled = true
IconController.controllerModeEnabled = false
IconController.previousTopbarEnabled = checkTopbarEnabled()
IconController.leftGap = 12
IconController.midGap = 12
IconController.rightGap = 12
IconController.leftOffset = 0
IconController.rightOffset = 0
IconController.mimicCoreGui = true
IconController.healthbarDisabled = false



-- EVENTS
IconController.iconAdded = Signal.new()
IconController.iconRemoved = Signal.new()
IconController.controllerModeStarted = Signal.new()
IconController.controllerModeEnded = Signal.new()
IconController.healthbarDisabledSignal = Signal.new()



-- CONNECTIONS
local iconCreationCount = 0
IconController.iconAdded:Connect(function(icon)
	topbarIcons[icon] = true
	if IconController.gameTheme then
		icon:setTheme(IconController.gameTheme)
	end
	icon.updated:Connect(function()
		IconController.updateTopbar()
	end)
	-- When this icon is selected, deselect other icons if necessary
	icon.selected:Connect(function()
		local allIcons = IconController.getIcons()
		for _, otherIcon in pairs(allIcons) do
			if icon.deselectWhenOtherIconSelected and otherIcon ~= icon and otherIcon.deselectWhenOtherIconSelected and otherIcon:getToggleState() == "selected" then
				otherIcon:deselect(icon)
			end
		end
	end)
	-- Order by creation if no order specified
	iconCreationCount = iconCreationCount + 1
	icon:setOrder(iconCreationCount)
	-- Apply controller view if enabled
	if IconController.controllerModeEnabled then
		IconController._enableControllerModeForIcon(icon, true)
	end
	IconController:_updateSelectionGroup()
	IconController.updateTopbar()
end)

IconController.iconRemoved:Connect(function(icon)
	topbarIcons[icon] = nil
	icon:setEnabled(false)
	icon:deselect()
	icon.updated:Fire()
	IconController:_updateSelectionGroup()
end)



-- METHODS
function IconController.setGameTheme(theme)
	IconController.gameTheme = theme
	local icons = IconController.getIcons()
	for _, icon in pairs(icons) do
		icon:setTheme(theme)
	end
end

function IconController.setDisplayOrder(value)
	value = tonumber(value) or TopbarPlusGui.DisplayOrder
	TopbarPlusGui.DisplayOrder = value
end
IconController.setDisplayOrder(10)

function IconController.getIcons()
	local allIcons = {}
	for otherIcon, _ in pairs(topbarIcons) do
		table.insert(allIcons, otherIcon)
	end
	return allIcons
end

function IconController.getIcon(name)
	for otherIcon, _ in pairs(topbarIcons) do
		if otherIcon.name == name then
			return otherIcon
		end
	end
	return false
end

function IconController.disableHealthbar(bool)
	local finalBool = (bool == nil or bool)
	IconController.healthbarDisabled = finalBool
	IconController.healthbarDisabledSignal:Fire(finalBool)
end

function IconController.canShowIconOnTopbar(icon)
	if (icon.enabled == true or icon.accountForWhenDisabled) and icon.presentOnTopbar then
		return true
	end
	return false
end

function IconController.getMenuOffset(icon)
	local alignment = icon:get("alignment")
	local alignmentGap = IconController[alignment.."Gap"]
	local iconSize = icon:get("iconSize") or UDim2.new(0, 32, 0, 32)
	local sizeX = iconSize.X.Offset
	local iconWidthAndGap = (sizeX + alignmentGap)
	local extendLeft = 0
	local extendRight = 0
	local additionalRight = 0
	if icon.menuOpen then
		local menuSize = icon:get("menuSize")
		local menuSizeXOffset = menuSize.X.Offset
		local direction = icon:_getMenuDirection()
		if direction == "right" then
			extendRight += menuSizeXOffset + alignmentGap/6--2
		elseif direction == "left" then
			extendLeft = menuSizeXOffset + 4
			extendRight += alignmentGap/3--4
			additionalRight = menuSizeXOffset
		end
	end
	return extendLeft, extendRight, additionalRight
end

-- This is responsible for positioning the topbar icons
local requestedTopbarUpdate = false
function IconController.updateTopbar()
	local function getIncrement(otherIcon, alignment)
		--local container = otherIcon.instances.iconContainer
		--local sizeX = container.Size.X.Offset
		local iconSize = otherIcon:get("iconSize", otherIcon:getIconState()) or UDim2.new(0, 32, 0, 32)
		local sizeX = iconSize.X.Offset
		local alignmentGap = IconController[alignment.."Gap"]
		local iconWidthAndGap = (sizeX + alignmentGap)
		local increment = iconWidthAndGap
		local preOffset = 0
		if otherIcon._parentIcon == nil then
			local extendLeft, extendRight, additionalRight = IconController.getMenuOffset(otherIcon)
			preOffset += extendLeft
			increment += extendRight + additionalRight
		end
		return increment, preOffset
	end
	if topbarUpdating then -- This prevents the topbar updating and shifting icons more than it needs to
		requestedTopbarUpdate = true
		return false
	end
	coroutine.wrap(function()
		topbarUpdating = true
		runService.Heartbeat:Wait()
		topbarUpdating = false
		
		for alignment, alignmentInfo in pairs(alignmentDetails) do
			alignmentInfo.records = {}
		end

		for otherIcon, _ in pairs(topbarIcons) do
			if IconController.canShowIconOnTopbar(otherIcon) then
				local alignment = otherIcon:get("alignment")
				table.insert(alignmentDetails[alignment].records, otherIcon)
			end
		end
		local viewportSize = workspace.CurrentCamera.ViewportSize
		for alignment, alignmentInfo in pairs(alignmentDetails) do
			local records = alignmentInfo.records
			if #records > 1 then
				if alignmentInfo.reverseSort then
					table.sort(records, function(a,b) return a:get("order") > b:get("order") end)
				else
					table.sort(records, function(a,b) return a:get("order") &lt; b:get("order") end)
				end
			end
			local totalIconX = 0
			for i, otherIcon in pairs(records) do
				local increment = getIncrement(otherIcon, alignment)
				totalIconX = totalIconX + increment
			end
			local offsetX = alignmentInfo.getStartOffset(totalIconX, alignment)
			local preOffsetX = offsetX
			local containerX = TopbarPlusGui.TopbarContainer.AbsoluteSize.X
			for i, otherIcon in pairs(records) do
				local increment, preOffset = getIncrement(otherIcon, alignment)
				local newAbsoluteX = alignmentInfo.startScale*containerX + preOffsetX+preOffset
				preOffsetX = preOffsetX + increment
			end
			for i, otherIcon in pairs(records) do
				local container = otherIcon.instances.iconContainer
				local increment, preOffset = getIncrement(otherIcon, alignment)
				local topPadding = otherIcon.topPadding
				local newPositon = UDim2.new(alignmentInfo.startScale, offsetX+preOffset, topPadding.Scale, topPadding.Offset)
				local isAnOverflowIcon = string.match(otherIcon.name, "_overflowIcon-")
				local repositionInfo = otherIcon:get("repositionInfo")
				if repositionInfo then
					tweenService:Create(container, repositionInfo, {Position = newPositon}):Play()
				else
					container.Position = newPositon
				end
				offsetX = offsetX + increment
				otherIcon.targetPosition = UDim2.new(0, (newPositon.X.Scale*viewportSize.X) + newPositon.X.Offset, 0, (newPositon.Y.Scale*viewportSize.Y) + newPositon.Y.Offset)
			end
		end

		-- OVERFLOW HANDLER
		--------
		local START_LEEWAY = 10 -- The additional offset where the end icon will be converted to ... without an apparant change in position
		local function getBoundaryX(iconToCheck, side, gap)
			local additionalGap = gap or 0
			local currentSize = iconToCheck:get("iconSize", iconToCheck:getIconState())
			local sizeX = currentSize.X.Offset
			local extendLeft, extendRight = IconController.getMenuOffset(iconToCheck)
			local boundaryXOffset = (side == "left" and (-additionalGap-extendLeft)) or (side == "right" and sizeX+additionalGap+extendRight)
			local boundaryX = iconToCheck.targetPosition.X.Offset + boundaryXOffset
			return boundaryX
		end
		local function getSizeX(iconToCheck, usePrevious)
			local currentSize, previousSize = iconToCheck:get("iconSize", iconToCheck:getIconState(), "beforeDropdown")
			local hoveringSize = iconToCheck:get("iconSize", "hovering")
			if iconToCheck.wasHoveringBeforeOverflow and previousSize and hoveringSize and hoveringSize.X.Offset > previousSize.X.Offset then
				-- This prevents hovering icons flicking back and forth, demonstrated at thread/1017485/191.
				previousSize = hoveringSize
			end
			local newSize = (usePrevious and previousSize) or currentSize
			local extendLeft, extendRight = IconController.getMenuOffset(iconToCheck)
			local sizeX = newSize.X.Offset + extendLeft + extendRight
			return sizeX
		end

		for alignment, alignmentInfo in pairs(alignmentDetails) do
			local overflowIcon = alignmentInfo.overflowIcon
			if overflowIcon then
				local alignmentGap = IconController[alignment.."Gap"]
				local oppositeAlignment = (alignment == "left" and "right") or "left"
				local oppositeAlignmentInfo = alignmentDetails[oppositeAlignment]
				local oppositeOverflowIcon = IconController.getIcon("_overflowIcon-"..oppositeAlignment)
				
				-- This determines whether any icons (from opposite or mid alignment) are overlapping with this alignment
				local overflowBoundaryX = getBoundaryX(overflowIcon, alignment)
				if overflowIcon.enabled then
					overflowBoundaryX = getBoundaryX(overflowIcon, oppositeAlignment, alignmentGap)
				end
				local function doesExceed(givenBoundaryX)
					local exceeds = (alignment == "left" and givenBoundaryX &lt; overflowBoundaryX) or (alignment == "right" and givenBoundaryX > overflowBoundaryX)
					return exceeds
				end
				local alignmentOffset = oppositeAlignmentInfo.getOffset()
				if not overflowIcon.enabled then
					alignmentOffset += START_LEEWAY
				end
				local alignmentBorderX = (alignment == "left" and viewportSize.X - alignmentOffset) or (alignment == "right" and alignmentOffset)
				local closestBoundaryX = alignmentBorderX
				local exceededCriticalBoundary = doesExceed(closestBoundaryX)
				local function checkBoundaryExceeded(recordToCheck)
					local totalIcons = #recordToCheck
					for i = 1, totalIcons do
						local endIcon = recordToCheck[totalIcons+1 - i]
						if IconController.canShowIconOnTopbar(endIcon) then
							local isAnOverflowIcon = string.match(endIcon.name, "_overflowIcon-")
							if isAnOverflowIcon and totalIcons ~= 1 then
								break
							elseif isAnOverflowIcon and not endIcon.enabled then
								continue
							end
							local additionalMyX = 0
							if not overflowIcon.enabled then
								additionalMyX = START_LEEWAY
							end
							local myBoundaryX = getBoundaryX(endIcon, alignment, additionalMyX)
							local isNowClosest = (alignment == "left" and myBoundaryX &lt; closestBoundaryX) or (alignment == "right" and myBoundaryX > closestBoundaryX)
							if isNowClosest then
								closestBoundaryX = myBoundaryX
								if doesExceed(myBoundaryX) then
									exceededCriticalBoundary = true
								end
							end
						end
					end
				end
				checkBoundaryExceeded(alignmentDetails[oppositeAlignment].records)
				checkBoundaryExceeded(alignmentDetails.mid.records)

				-- This determines which icons to give to the overflow if an overlap is present
				if exceededCriticalBoundary then
					local recordToCheck = alignmentInfo.records
					local totalIcons = #recordToCheck
					for i = 1, totalIcons do
						local endIcon = (alignment == "left" and recordToCheck[totalIcons+1 - i]) or (alignment == "right" and recordToCheck[i])
						if endIcon ~= overflowIcon and IconController.canShowIconOnTopbar(endIcon) then
							local additionalGap = alignmentGap
							local overflowIconSizeX = overflowIcon:get("iconSize", overflowIcon:getIconState()).X.Offset
							if overflowIcon.enabled then
								additionalGap += alignmentGap + overflowIconSizeX
							end
							local myBoundaryXPlusGap = getBoundaryX(endIcon, oppositeAlignment, additionalGap)
							local exceeds = (alignment == "left" and myBoundaryXPlusGap >= closestBoundaryX) or (alignment == "right" and myBoundaryXPlusGap &lt;= closestBoundaryX)
							if exceeds then
								if not overflowIcon.enabled then
									local overflowContainer = overflowIcon.instances.iconContainer
									local yPos = overflowContainer.Position.Y
									local appearXAdditional = (alignment == "left" and -overflowContainer.Size.X.Offset) or 0
									local appearX = getBoundaryX(endIcon, oppositeAlignment, appearXAdditional)
									overflowContainer.Position = UDim2.new(0, appearX, yPos.Scale, yPos.Offset)
									overflowIcon:setEnabled(true)
								end
								if #endIcon.dropdownIcons > 0 then
									endIcon._overflowConvertedToMenu = true
									local wasSelected = endIcon.isSelected
									endIcon:deselect()
									local iconsToConvert = {}
									for _, dIcon in pairs(endIcon.dropdownIcons) do
										table.insert(iconsToConvert, dIcon)
									end
									for _, dIcon in pairs(endIcon.dropdownIcons) do
										dIcon:leave()
									end
									endIcon:setMenu(iconsToConvert)
									if wasSelected and overflowIcon.isSelected then
										endIcon:select()
									end
								end
								if endIcon.hovering then
									endIcon.wasHoveringBeforeOverflow = true
								end
								endIcon:join(overflowIcon, "dropdown")
								if #endIcon.menuIcons > 0 and endIcon.menuOpen then
									endIcon:deselect()
									endIcon:select()
									overflowIcon:select()
								end
							end
							break
						end
					end
				
				else
					
					-- This checks to see if the lowest/highest (depending on left/right) ordered overlapping icon is no longer overlapping, removes from the dropdown, and repeats if valid
					local winningOrder, winningOverlappedIcon
					local totalOverlappingIcons = #overflowIcon.dropdownIcons
					if not (oppositeOverflowIcon and oppositeOverflowIcon.enabled and #alignmentInfo.records == 1 and #oppositeAlignmentInfo.records ~= 1) then
						for _, overlappedIcon in pairs(overflowIcon.dropdownIcons) do
							local iconOrder = overlappedIcon:get("order")
							if winningOverlappedIcon == nil or (alignment == "left" and iconOrder &lt; winningOrder) or (alignment == "right" and iconOrder > winningOrder) then
								winningOrder = iconOrder
								winningOverlappedIcon = overlappedIcon
							end
						end
					end
					if winningOverlappedIcon then
						local sizeX = getSizeX(winningOverlappedIcon, true)
						local myForesightBoundaryX = getBoundaryX(overflowIcon, oppositeAlignment)
						if totalOverlappingIcons == 1 then
							myForesightBoundaryX = getBoundaryX(overflowIcon, alignment, alignmentGap-START_LEEWAY)
						end
						local availableGap = math.abs(closestBoundaryX - myForesightBoundaryX) - (alignmentGap*2)
						local noLongerExeeds = (sizeX &lt; availableGap)
						if noLongerExeeds then
							if #overflowIcon.dropdownIcons == 1 then
								overflowIcon:setEnabled(false)
							end
							local overflowContainer = overflowIcon.instances.iconContainer
							local yPos = overflowContainer.Position.Y
							overflowContainer.Position = UDim2.new(0, myForesightBoundaryX, yPos.Scale, yPos.Offset)
							winningOverlappedIcon:leave()
							winningOverlappedIcon.wasHoveringBeforeOverflow = nil
							--
							if winningOverlappedIcon._overflowConvertedToMenu then
								winningOverlappedIcon._overflowConvertedToMenu = nil
								local iconsToConvert = {}
								for _, dIcon in pairs(winningOverlappedIcon.menuIcons) do
									table.insert(iconsToConvert, dIcon)
								end
								for _, dIcon in pairs(winningOverlappedIcon.menuIcons) do
									dIcon:leave()
								end
								winningOverlappedIcon:setDropdown(iconsToConvert)
							end
							--
						end
					end

				end
			end
		end
		--------
		if requestedTopbarUpdate then
			requestedTopbarUpdate = false
			IconController.updateTopbar()
		end
		return true
	end)()
end

function IconController.setTopbarEnabled(bool, forceBool)
	if forceBool == nil then
		forceBool = true
	end
	local indicator = TopbarPlusGui.Indicator
	if forceBool and not bool then
		forceTopbarDisabled = true
	elseif forceBool and bool then
		forceTopbarDisabled = false
	end
	local topbarEnabledAccountingForMimic = checkTopbarEnabledAccountingForMimic()
	if IconController.controllerModeEnabled then
		if bool then
			if TopbarPlusGui.TopbarContainer.Visible or forceTopbarDisabled or menuOpen or not topbarEnabledAccountingForMimic then return end
			if forceBool then
				indicator.Visible = topbarEnabledAccountingForMimic
			else
				if hapticService:IsVibrationSupported(Enum.UserInputType.Gamepad1) and hapticService:IsMotorSupported(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small) then
					hapticService:SetMotor(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small,1)
					delay(0.2,function()
						pcall(function()
							hapticService:SetMotor(Enum.UserInputType.Gamepad1,Enum.VibrationMotor.Small,0)
						end)
					end)
				end
				TopbarPlusGui.TopbarContainer.Visible = true
				TopbarPlusGui.TopbarContainer:TweenPosition(
					UDim2.new(0,0,0,5 + STUPID_CONTROLLER_OFFSET),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Quad,
					0.1,
					true
				)
				
				
				local selectIcon
				local targetOffset = 0
				IconController:_updateSelectionGroup()
				runService.Heartbeat:Wait()
				local indicatorSizeTrip = 50 --indicator.AbsoluteSize.Y * 2
				for otherIcon, _ in pairs(topbarIcons) do
					if IconController.canShowIconOnTopbar(otherIcon) and (selectIcon == nil or otherIcon:get("order") > selectIcon:get("order")) then
						selectIcon = otherIcon
					end
					local container = otherIcon.instances.iconContainer
					local newTargetOffset = -27 + container.AbsoluteSize.Y + indicatorSizeTrip
					if newTargetOffset > targetOffset then
						targetOffset = newTargetOffset
					end
				end
				if guiService:GetEmotesMenuOpen() then
					guiService:SetEmotesMenuOpen(false)
				end
				if guiService:GetInspectMenuEnabled() then
					guiService:CloseInspectMenu()
				end
				local newSelectedObject = IconController._previousSelectedObject or selectIcon.instances.iconButton
				IconController._setControllerSelectedObject(newSelectedObject)
				indicator.Image = "rbxassetid://5278151071"
				indicator:TweenPosition(
					UDim2.new(0.5,0,0,targetOffset + STUPID_CONTROLLER_OFFSET),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Quad,
					0.1,
					true
				)
			end
		else
			if forceBool then
				indicator.Visible = false
			else
				indicator.Visible = topbarEnabledAccountingForMimic
			end
			if not TopbarPlusGui.TopbarContainer.Visible then return end
			guiService.AutoSelectGuiEnabled = true
			IconController:_updateSelectionGroup(true)
			TopbarPlusGui.TopbarContainer:TweenPosition(
				UDim2.new(0,0,0,-TopbarPlusGui.TopbarContainer.Size.Y.Offset + STUPID_CONTROLLER_OFFSET),
				Enum.EasingDirection.Out,
				Enum.EasingStyle.Quad,
				0.1,
				true,
				function()
					TopbarPlusGui.TopbarContainer.Visible = false
				end
			)
			indicator.Image = "rbxassetid://5278151556"
			indicator:TweenPosition(
				UDim2.new(0.5,0,0,5),
				Enum.EasingDirection.Out,
				Enum.EasingStyle.Quad,
				0.1,
				true
			)
		end
	else
		local topbarContainer = TopbarPlusGui.TopbarContainer
		if topbarEnabledAccountingForMimic then
			topbarContainer.Visible = bool
		else
			topbarContainer.Visible = false
		end
	end
end

function IconController.setGap(value, alignment)
	local newValue = tonumber(value) or 12
	local newAlignment = tostring(alignment):lower()
	if newAlignment == "left" or newAlignment == "mid" or newAlignment == "right" then
		IconController[newAlignment.."Gap"] = newValue
		IconController.updateTopbar()
		return
	end
	IconController.leftGap = newValue
	IconController.midGap = newValue
	IconController.rightGap = newValue
	IconController.updateTopbar()
end

function IconController.setLeftOffset(value)
	IconController.leftOffset = tonumber(value) or 0
	IconController.updateTopbar()
end

function IconController.setRightOffset(value)
	IconController.rightOffset = tonumber(value) or 0
	IconController.updateTopbar()
end

local localPlayer = players.LocalPlayer
local iconsToClearOnSpawn = {}
localPlayer.CharacterAdded:Connect(function()
	for _, icon in pairs(iconsToClearOnSpawn) do
		icon:destroy()
	end
	iconsToClearOnSpawn = {}
end)
function IconController.clearIconOnSpawn(icon)
	coroutine.wrap(function()
		local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
		table.insert(iconsToClearOnSpawn, icon)
	end)()
end



-- PRIVATE METHODS
function IconController:_updateSelectionGroup(clearAll)
	if IconController._navigationEnabled then
		guiService:RemoveSelectionGroup("TopbarPlusIcons")
	end
	if clearAll then
		guiService.CoreGuiNavigationEnabled = IconController._originalCoreGuiNavigationEnabled
		guiService.GuiNavigationEnabled = IconController._originalGuiNavigationEnabled
		IconController._navigationEnabled = nil
	elseif IconController.controllerModeEnabled then
		local icons = IconController.getIcons()
		local iconContainers = {}
		for i, otherIcon in pairs(icons) do
			local featureName = otherIcon.joinedFeatureName
			if not featureName or otherIcon._parentIcon[otherIcon.joinedFeatureName.."Open"] == true then
				table.insert(iconContainers, otherIcon.instances.iconButton)
			end
		end
		guiService:AddSelectionTuple("TopbarPlusIcons", table.unpack(iconContainers))
		if not IconController._navigationEnabled then
			IconController._originalCoreGuiNavigationEnabled = guiService.CoreGuiNavigationEnabled
			IconController._originalGuiNavigationEnabled = guiService.GuiNavigationEnabled
			guiService.CoreGuiNavigationEnabled = false
			guiService.GuiNavigationEnabled = true
			IconController._navigationEnabled = true
		end
	end
end

local function getScaleMultiplier()
	if guiService:IsTenFootInterface() then
		return 3
	else
		return 1.3
	end
end

function IconController._setControllerSelectedObject(object)
	local startId = (IconController._controllerSetCount and IconController._controllerSetCount + 1) or 0
	IconController._controllerSetCount = startId
	guiService.SelectedObject = object
	delay(0.1, function() -- blame the roblox guiservice its a piece of doo doo
		local finalId = IconController._controllerSetCount
		if startId == finalId then
			guiService.SelectedObject = object
		end
	end)
end

function IconController._enableControllerMode(bool)
	local indicator = TopbarPlusGui.Indicator
	local controllerOptionIcon = IconController.getIcon("_TopbarControllerOption")
	if IconController.controllerModeEnabled == bool then
		return
	end
	IconController.controllerModeEnabled = bool
	if bool then
		TopbarPlusGui.TopbarContainer.Position = UDim2.new(0,0,0,5)
		TopbarPlusGui.TopbarContainer.Visible = false
		local scaleMultiplier = getScaleMultiplier()
		indicator.Position = UDim2.new(0.5,0,0,5)
		indicator.Size = UDim2.new(0, 18*scaleMultiplier, 0, 18*scaleMultiplier)
		indicator.Image = "rbxassetid://5278151556"
		indicator.Visible = checkTopbarEnabledAccountingForMimic()
		indicator.Position = UDim2.new(0.5,0,0,5)
	else
		TopbarPlusGui.TopbarContainer.Position = UDim2.new(0,0,0,0)
		TopbarPlusGui.TopbarContainer.Visible = checkTopbarEnabledAccountingForMimic()
		indicator.Visible = false
		IconController._setControllerSelectedObject(nil)
	end
	for icon, _ in pairs(topbarIcons) do
		IconController._enableControllerModeForIcon(icon, bool)
	end
end

function IconController._enableControllerModeForIcon(icon, bool)
	local parentIcon = icon._parentIcon
	local featureName = icon.joinedFeatureName
	if parentIcon then
		icon:leave()
	end
	if bool then
		local scaleMultiplier = getScaleMultiplier()
		local currentSizeDeselected = icon:get("iconSize", "deselected")
		local currentSizeSelected = icon:get("iconSize", "selected")
		local currentSizeHovering = icon:getHovering("iconSize")
		icon:set("iconSize", UDim2.new(0, currentSizeDeselected.X.Offset*scaleMultiplier, 0, currentSizeDeselected.Y.Offset*scaleMultiplier), "deselected", "controllerMode")
		icon:set("iconSize", UDim2.new(0, currentSizeSelected.X.Offset*scaleMultiplier, 0, currentSizeSelected.Y.Offset*scaleMultiplier), "selected", "controllerMode")
		if currentSizeHovering then
			icon:set("iconSize", UDim2.new(0, currentSizeSelected.X.Offset*scaleMultiplier, 0, currentSizeSelected.Y.Offset*scaleMultiplier), "hovering", "controllerMode")
		end
		icon:set("alignment", "mid", "deselected", "controllerMode")
		icon:set("alignment", "mid", "selected", "controllerMode")
	else
		local states = {"deselected", "selected", "hovering"}
		for _, iconState in pairs(states) do
			local _, previousAlignment = icon:get("alignment", iconState, "controllerMode")
			if previousAlignment then
				icon:set("alignment", previousAlignment, iconState)
			end
			local currentSize, previousSize = icon:get("iconSize", iconState, "controllerMode")
			if previousSize then
				icon:set("iconSize", previousSize, iconState)
			end
		end
	end
	if parentIcon then
		icon:join(parentIcon, featureName)
	end
end

local createdFakeHealthbarIcon = false
function IconController.setupHealthbar()

	if createdFakeHealthbarIcon then
		return
	end
	createdFakeHealthbarIcon = true

	-- Create a fake healthbar icon to mimic the core health gui
	task.defer(function()
		runService.Heartbeat:Wait()
		local Icon = require(script.Parent)

		Icon.new()
			:setProperty("internalIcon", true)
			:setName("_FakeHealthbar")
			:setRight()
			:setOrder(-420)
			:setSize(80, 32)
			:lock()
			:set("iconBackgroundTransparency", 1)
			:give(function(icon)

				local healthContainer = Instance.new("Frame")
				healthContainer.Name = "HealthContainer"
				healthContainer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
				healthContainer.BorderSizePixel = 0
				healthContainer.AnchorPoint = Vector2.new(0, 0.5)
				healthContainer.Position = UDim2.new(0, 0, 0.5, 0)
				healthContainer.Size = UDim2.new(1, 0, 0.2, 0)
				healthContainer.Visible = true
				healthContainer.ZIndex = 11
				print("icon = ", icon)
				print("icon.instances = ", icon.instances)
				print("icon.instances.iconButton = ", icon.instances.iconButton)
				healthContainer.Parent = icon.instances.iconButton

				local corner = Instance.new("UICorner")
				corner.CornerRadius = UDim.new(1, 0)
				corner.Parent = healthContainer

				local healthFrame = healthContainer:Clone()
				healthFrame.Name = "HealthFrame"
				healthFrame.BackgroundColor3 = Color3.fromRGB(167, 167, 167)
				healthFrame.BorderSizePixel = 0
				healthFrame.AnchorPoint = Vector2.new(0.5, 0.5)
				healthFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
				healthFrame.Size = UDim2.new(1, -2, 1, -2)
				healthFrame.Visible = true
				healthFrame.ZIndex = 12
				healthFrame.Parent = healthContainer

				local healthBar = healthFrame:Clone()
				healthBar.Name = "HealthBar"
				healthBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				healthBar.BorderSizePixel = 0
				healthBar.AnchorPoint = Vector2.new(0, 0.5)
				healthBar.Position = UDim2.new(0, 0, 0.5, 0)
				healthBar.Size = UDim2.new(0.5, 0, 1, 0)
				healthBar.Visible = true
				healthBar.ZIndex = 13
				healthBar.Parent = healthFrame

				local START_HEALTHBAR_COLOR = Color3.fromRGB(27, 252, 107)
				local MID_HEALTHBAR_COLOR = Color3.fromRGB(250, 235, 0)
				local END_HEALTHBAR_COLOR = Color3.fromRGB(255, 28, 0)

				local function powColor3(color, pow)
					return Color3.new(
						math.pow(color.R, pow),
						math.pow(color.G, pow),
						math.pow(color.B, pow)
					)
				end

				local function lerpColor(colorA, colorB, frac, gamma)
					gamma = gamma or 2.0
					local CA = powColor3(colorA, gamma)
					local CB = powColor3(colorB, gamma)
					return powColor3(CA:Lerp(CB, frac), 1/gamma)
				end

				local firstTimeEnabling = true
				local function listenToHealth(character)
					if not character then
						return
					end
					local humanoid = character:WaitForChild("Humanoid", 10)
					if not humanoid then
						return
					end

					local function updateHealthBar()
						local realHealthbarEnabled = starterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Health)
						local healthInterval = humanoid.Health / humanoid.MaxHealth
						if healthInterval == 1 or IconController.healthbarDisabled or (firstTimeEnabling and realHealthbarEnabled == false) then
							if icon.enabled then
								icon:setEnabled(false)
							end
							return
						elseif healthInterval &lt; 1 then
							if not icon.enabled then
								icon:setEnabled(true)
							end
							firstTimeEnabling = false
							if realHealthbarEnabled then
								starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)
							end
						end
						local startInterval = 0.9
						local endInterval = 0.1
						local m = 1/(startInterval - endInterval)
						local c = -m*endInterval
						local colorIntervalAbsolute = (m*healthInterval) + c
						local colorInterval = (colorIntervalAbsolute > 1 and 1) or (colorIntervalAbsolute &lt; 0 and 0) or colorIntervalAbsolute
						local firstColor = (healthInterval > 0.5 and START_HEALTHBAR_COLOR) or MID_HEALTHBAR_COLOR
						local lastColor = (healthInterval > 0.5 and MID_HEALTHBAR_COLOR) or END_HEALTHBAR_COLOR
						local doubleSubtractor = (1-colorInterval)*2
						local modifiedColorInterval = (healthInterval > 0.5 and (1-doubleSubtractor)) or (2-doubleSubtractor)
						local newHealthFillColor = lerpColor(lastColor, firstColor, modifiedColorInterval)
						local newHealthFillSize = UDim2.new(healthInterval, 0, 1, 0)
						healthBar.BackgroundColor3 = newHealthFillColor
						healthBar.Size = newHealthFillSize
					end

					humanoid.HealthChanged:Connect(updateHealthBar)
					IconController.healthbarDisabledSignal:Connect(updateHealthBar)
					updateHealthBar()
				end
				localPlayer.CharacterAdded:Connect(function(character)
					listenToHealth(character)
				end)
				task.spawn(listenToHealth, localPlayer.Character)
			end)
	end)
end



-- BEHAVIOUR
--Controller support
coroutine.wrap(function()
	
	-- Create PC 'Enter Controller Mode' Icon
	runService.Heartbeat:Wait() -- This is required to prevent an infinite recursion
	local Icon = require(script.Parent)
	local controllerOptionIcon = Icon.new()
		:setProperty("internalIcon", true)
		:setName("_TopbarControllerOption")
		:setOrder(100)
		:setImage("rbxassetid://5278150942")
		:setRight()
		:setEnabled(false)
		:setTip("Controller mode")
		:setProperty("deselectWhenOtherIconSelected", false)

	-- This decides what controller widgets and displays to show based upon their connected inputs
	-- For example, if on PC with a controller, give the player the option to enable controller mode with a toggle
	-- While if using a console (no mouse, but controller) then bypass the toggle and automatically enable controller mode
	local function determineDisplay()
		local mouseEnabled = userInputService.MouseEnabled
		local controllerEnabled = userInputService.GamepadEnabled
		local iconIsSelected = controllerOptionIcon.isSelected
		if mouseEnabled and controllerEnabled then
			-- Show icon
			controllerOptionIcon:setEnabled(true)
		elseif mouseEnabled and not controllerEnabled then
			-- Hide icon, disableControllerMode
			controllerOptionIcon:setEnabled(false)
			IconController._enableControllerMode(false)
			controllerOptionIcon:deselect()
		elseif not mouseEnabled and controllerEnabled then
			-- Hide icon, _enableControllerMode
			controllerOptionIcon:setEnabled(false)
			IconController._enableControllerMode(true)
		end
	end
	userInputService:GetPropertyChangedSignal("MouseEnabled"):Connect(determineDisplay)
	userInputService.GamepadConnected:Connect(determineDisplay)
	userInputService.GamepadDisconnected:Connect(determineDisplay)
	determineDisplay()

	-- Enable/Disable Controller Mode when icon clicked
	local function iconClicked()
		local isSelected = controllerOptionIcon.isSelected
		local iconTip = (isSelected and "Normal mode") or "Controller mode"
		controllerOptionIcon:setTip(iconTip)
		IconController._enableControllerMode(isSelected)
	end
	controllerOptionIcon.selected:Connect(iconClicked)
	controllerOptionIcon.deselected:Connect(iconClicked)

	-- Hide/show topbar when indicator action selected in controller mode
	userInputService.InputBegan:Connect(function(input,gpe)
		if not IconController.controllerModeEnabled then return end
		if input.KeyCode == Enum.KeyCode.DPadDown then
			if not guiService.SelectedObject and checkTopbarEnabledAccountingForMimic() then
				IconController.setTopbarEnabled(true,false)
			end
		elseif input.KeyCode == Enum.KeyCode.ButtonB then
			IconController._previousSelectedObject = guiService.SelectedObject
			IconController._setControllerSelectedObject(nil)
			IconController.setTopbarEnabled(false,false)
		end
		input:Destroy()
	end)

	-- Setup overflow icons
	for alignment, detail in pairs(alignmentDetails) do
		if alignment ~= "mid" then
			local overflowName = "_overflowIcon-"..alignment
			local overflowIcon = Icon.new()
				:setProperty("internalIcon", true)
				:setImage(6069276526)
				:setName(overflowName)
				:setEnabled(false)
			detail.overflowIcon = overflowIcon
			overflowIcon.accountForWhenDisabled = true
			if alignment == "left" then
				overflowIcon:setOrder(math.huge)
				overflowIcon:setLeft()
				overflowIcon:set("dropdownAlignment", "right")
			elseif alignment == "right" then
				overflowIcon:setOrder(-math.huge)
				overflowIcon:setRight()
				overflowIcon:set("dropdownAlignment", "left")
			end
			overflowIcon.lockedSettings = {
				["iconImage"] = true,
				["order"] = true,
				["alignment"] = true,
			}
		end
	end
end)()

-- Mimic the enabling of the topbar when StarterGui:SetCore("TopbarEnabled", state) is called
coroutine.wrap(function()
	local chatScript = players.LocalPlayer.PlayerScripts:WaitForChild("ChatScript", 4) or game:GetService("Chat"):WaitForChild("ChatScript", 4)
	if not chatScript then return end
	local chatMain = chatScript:FindFirstChild("ChatMain")
	if not chatMain then return end
	local ChatMain = require(chatMain)
	ChatMain.CoreGuiEnabled:connect(function()
		local topbarEnabled = checkTopbarEnabled()
		if topbarEnabled == IconController.previousTopbarEnabled then
			IconController.updateTopbar()
			return "SetCoreGuiEnabled was called instead of SetCore"
		end
		if IconController.mimicCoreGui then
			IconController.previousTopbarEnabled = topbarEnabled
			if IconController.controllerModeEnabled then
				IconController.setTopbarEnabled(false,false)
			else
				IconController.setTopbarEnabled(topbarEnabled,false)
			end
		end
		IconController.updateTopbar()
	end)
	local makeVisible = checkTopbarEnabled()
	if not makeVisible and not IconController.mimicCoreGui then
		makeVisible = true
	end
	IconController.setTopbarEnabled(makeVisible, false)
end)()

-- Mimic roblox menu when opened and closed
guiService.MenuClosed:Connect(function()
	menuOpen = false
	if not IconController.controllerModeEnabled then
		IconController.setTopbarEnabled(IconController.topbarEnabled,false)
	end
end)
guiService.MenuOpened:Connect(function()
	menuOpen = true
	IconController.setTopbarEnabled(false,false)
end)

-- Add icons to an overflow if they overlap the screen bounds or other icons
workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	IconController.updateTopbar()
end)



return IconController</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="33">
                <Properties>
                  <string name="Name">Maid</string>
                  <string name="Source">-- Maid
-- Author: Quenty
-- Source: https://github.com/Quenty/NevermoreEngine/blob/8ef4242a880c645b2f82a706e8074e74f23aab06/Modules/Shared/Events/Maid.lua
-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)


---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	return setmetatable({
		_tasks = {}
	}, Maid)
end

function Maid.isMaid(value)
	return type(value) == "table" and value.ClassName == "Maid"
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up. Tasks given to a maid will be cleaned when
--  maid[index] is set to a different value.
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
		return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		elseif oldTask.destroy then
			oldTask:destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:giveTask(task)
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not (task.Destroy or task.destroy)) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[[ I wont' be using promises for TopbarPlus so we can ignore this method
function Maid:givePromise(promise)
	if (promise:getStatus() ~= Promise.Status.Started) then
		return promise
	end

	local newPromise = Promise.resolve(promise)
	local id = self:giveTask(newPromise)

	-- Ensure GC
	newPromise:finally(function()
		self[id] = nil
	end)

	return newPromise, id
end--]]

function Maid:give(taskOrPromise)
	local taskId
	if type(taskOrPromise) == "table" and taskOrPromise.isAPromise then
---@diagnostic disable-next-line: undefined-global
		_, taskId = self:givePromise(taskOrPromise)
	else
		taskId = self:giveTask(taskOrPromise)
	end
	return taskOrPromise, taskId
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:doCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if typeof(task) == "RBXScriptConnection" then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		if type(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif task.Destroy then
			task:Destroy()
		elseif task.destroy then
			task:destroy()
		end
		index, task = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.destroy = Maid.doCleaning
Maid.clean = Maid.doCleaning

return Maid</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">Signal</string>
                  <string name="Source">local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local heartbeat = RunService.Heartbeat
local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"
Signal.totalConnections = 0



-- CONSTRUCTOR
function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({}, Signal)
	
	if createConnectionsChangedSignal then
		self.connectionsChanged = Signal.new()
	end

	self.connections = {}
	self.totalConnections = 0
	self.waiting = {}
	self.totalWaiting = 0

	return self
end



-- METHODS
function Signal:Fire(...)
	for _, connection in pairs(self.connections) do
		connection.Handler(...)
	end
	if self.totalWaiting > 0 then
		local packedArgs = table.pack(...)
		for waitingId, _ in pairs(self.waiting) do
			self.waiting[waitingId] = packedArgs
		end
	end
end
Signal.fire = Signal.Fire

function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end
	
	local signal = self
	local connectionId = HttpService:GenerateGUID(false)
	local connection = {}
	connection.Connected = true
	connection.ConnectionId = connectionId
	connection.Handler = handler
	self.connections[connectionId] = connection

	function connection:Disconnect()
		signal.connections[connectionId] = nil
		connection.Connected = false
		signal.totalConnections -= 1
		if signal.connectionsChanged then
			signal.connectionsChanged:Fire(-1)
		end
	end
	connection.Destroy = connection.Disconnect
	connection.destroy = connection.Disconnect
	connection.disconnect = connection.Disconnect
	self.totalConnections += 1
	if self.connectionsChanged then
		self.connectionsChanged:Fire(1)
	end

	return connection
end
Signal.connect = Signal.Connect

function Signal:Wait()
	local waitingId = HttpService:GenerateGUID(false)
	self.waiting[waitingId] = true
	self.totalWaiting += 1
	repeat heartbeat:Wait() until self.waiting[waitingId] ~= true
	self.totalWaiting -= 1
	local args = self.waiting[waitingId]
	self.waiting[waitingId] = nil
	return unpack(args)
end
Signal.wait = Signal.Wait

function Signal:Destroy()
	if self.bindableEvent then
		self.bindableEvent:Destroy()
		self.bindableEvent = nil
	end
	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
	end
	self.totalConnections = 0
	for connectionId, connection in pairs(self.connections) do
		self.connections[connectionId] = nil
	end
end
Signal.destroy = Signal.Destroy
Signal.Disconnect = Signal.Destroy
Signal.disconnect = Signal.Destroy



return Signal</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="35">
                <Properties>
                  <string name="Name">Themes</string>
                  <string name="Source">-- Require all children and return their references
local Themes = {}
for _, module in pairs(script:GetChildren()) do
    if module:IsA("ModuleScript") then
        Themes[module.Name] = require(module)
    end
end
return Themes</string>
                </Properties>
                <Item class="ModuleScript" referent="36">
                  <Properties>
                    <string name="Name">BlueGradient</string>
                    <string name="Source"><![CDATA[-- BlueGradient by ForeverHD
local selectedColor = Color3.fromRGB(0, 170, 255)
local selectedColorDarker = Color3.fromRGB(0, 120, 180)
local neutralColor = Color3.fromRGB(255, 255, 255)
return {
    
    -- Settings which describe how an item behaves or transitions between states
    action =  {
        resizeInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back),
        repositionInfo = TweenInfo.new(0.2, Enum.EasingStyle.Back),
    },
    
    -- Settings which describe how an item appears when 'deselected' and 'selected'
    toggleable = {
        -- How items appear normally (i.e. when they're 'deselected')
        deselected = {
            iconGradientColor = ColorSequence.new(selectedColor, selectedColorDarker),
            iconGradientRotation = 90,
            noticeCircleColor = selectedColor,
            noticeCircleImage = "http://www.roblox.com/asset/?id=4882430005",
            noticeTextColor = neutralColor,
            captionOverlineColor = selectedColor,
        },
        -- How items appear after the icon has been clicked (i.e. when they're 'selected')
        -- If a selected value is not specified, it will default to the deselected value
        selected = {
            iconBackgroundColor = Color3.fromRGB(255, 255, 255),
            iconBackgroundTransparency = 0.1,
            iconGradientColor = ColorSequence.new(selectedColor, selectedColorDarker),
            iconGradientRotation = 90,
            iconImageColor = Color3.fromRGB(255, 255, 255),
            iconTextColor = Color3.fromRGB(255, 255, 255),
            noticeCircleColor = neutralColor,
            noticeTextColor = selectedColor,
        }
    },
    
    -- Settings where toggleState doesn't matter (they have a singular state)
    other =  {},
    
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="37">
                  <Properties>
                    <string name="Name">Default</string>
                    <string name="Source">--[[
This file is necessary for constructing the default Icon template
Do not remove this module otherwise TopbarPlus will break
Modifying this file may also cause TopbarPlus to break
It's recommended instead to create a separate theme module and use that instead

To apply your theme after creating it, do:
```lua
local IconController = require(pathway.to.IconController)
local Themes = require(pathway.to.Themes)
IconController.setGameTheme(Themes.YourThemeName)
```

or by applying to an individual icon:
```lua
local Icon = require(pathway.to.Icon)
local Themes = require(pathway.to.Themes)
local newIcon = Icon.new()
    :setTheme(Themes.YourThemeName)
```
--]]

return {
    
    -- Settings which describe how an item behaves or transitions between states
    action =  {
        toggleTransitionInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        resizeInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        repositionInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        captionFadeInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        tipFadeInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        dropdownSlideInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        menuSlideInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
    },

    -- Settings which describe how an item appears when 'deselected' and 'selected'
    toggleable = {
        -- How items appear normally (i.e. when they're 'deselected')
        deselected = {
            iconBackgroundColor = Color3.fromRGB(0, 0, 0),
            iconBackgroundTransparency = 0.5,
            iconCornerRadius = UDim.new(0.25, 0),
            iconGradientColor = ColorSequence.new(Color3.fromRGB(255, 255, 255)),
            iconGradientRotation = 0,
            iconImage = "",
            iconImageColor =Color3.fromRGB(255, 255, 255),
            iconImageTransparency = 0,
            iconImageYScale = 0.63,
            iconImageRatio = 1,
            iconLabelYScale = 0.45,
            iconScale = UDim2.new(1, 0, 1, 0),
            forcedIconSize = UDim2.new(0, 32, 0, 32);
            iconSize = UDim2.new(0, 32, 0, 32),
            iconOffset = UDim2.new(0, 0, 0, 0),
            iconText = "",
            iconTextColor = Color3.fromRGB(255, 255, 255),
            iconFont = Enum.Font.GothamSemibold,
            noticeCircleColor = Color3.fromRGB(255, 255, 255),
            noticeCircleImage = "http://www.roblox.com/asset/?id=4871790969",
            noticeTextColor = Color3.fromRGB(31, 33, 35),
            baseZIndex = 1,
            order = 1,
            alignment = "left",
            clickSoundId = "rbxassetid://5273899897",
            clickVolume = 0,
            clickPlaybackSpeed = 1,
            clickTimePosition = 0.12
        },
        -- How items appear after the icon has been clicked (i.e. when they're 'selected')
        -- If a selected value is not specified, it will default to the deselected value
        selected = {
            iconBackgroundColor = Color3.fromRGB(245, 245, 245),
            iconBackgroundTransparency = 0.1,
            iconImageColor = Color3.fromRGB(57, 60, 65),
            iconTextColor = Color3.fromRGB(57, 60, 65),
            clickPlaybackSpeed = 1.5,
        }
    },

    -- Settings where toggleState doesn't matter (they have a singular state)
    other = {
        -- Caption settings
        captionBackgroundColor = Color3.fromRGB(0, 0, 0),
        captionBackgroundTransparency = 0.5,
        captionTextColor = Color3.fromRGB(255, 255, 255),
        captionTextTransparency = 0,
        captionFont = Enum.Font.GothamSemibold,
        captionOverlineColor = Color3.fromRGB(0, 170, 255),
        captionOverlineTransparency = 0,
        captionCornerRadius = UDim.new(0.25, 0),
        -- Tip settings
        tipBackgroundColor = Color3.fromRGB(255, 255, 255),
        tipBackgroundTransparency = 0.1,
        tipTextColor = Color3.fromRGB(27, 42, 53),
        tipTextTransparency = 0,
        tipFont = Enum.Font.GothamSemibold,
        tipCornerRadius = UDim.new(0.175, 0),
        -- Dropdown settings
        dropdownAlignment = "auto", -- 'left', 'mid', 'right' or 'auto' (auto is where the dropdown alignment matches the icons alignment)
        dropdownMaxIconsBeforeScroll = 3,
        dropdownMinWidth = 32,
        dropdownSquareCorners = false,
        dropdownBindToggleToIcon = true,
        dropdownToggleOnLongPress = false,
        dropdownToggleOnRightClick = false,
        dropdownCloseOnTapAway = false,
        dropdownHidePlayerlistOnOverlap = true,
        dropdownListPadding = UDim.new(0, 2),
        dropdownScrollBarColor = Color3.fromRGB(25, 25, 25),
        dropdownScrollBarTransparency = 0.2,
        dropdownScrollBarThickness = 4,
        -- Menu settings
        menuDirection = "auto", -- 'left', 'right' or 'auto' (for auto, if alignment is 'left' or 'mid', menuDirection will be 'right', else menuDirection is 'left')
        menuMaxIconsBeforeScroll = 4,
        menuBindToggleToIcon = true,
        menuToggleOnLongPress = false,
        menuToggleOnRightClick = false,
        menuCloseOnTapAway = false,
        menuScrollBarColor = Color3.fromRGB(25, 25, 25),
        menuScrollBarTransparency = 0.2,
        menuScrollBarThickness = 4,
    },
    
}</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">TopbarPlusGui</string>
                  <string name="Source">-- SETUP ICON TEMPLATE
local topbarPlusGui = Instance.new("ScreenGui")
topbarPlusGui.Enabled = true
topbarPlusGui.DisplayOrder = 0
topbarPlusGui.IgnoreGuiInset = true
topbarPlusGui.ResetOnSpawn = false
topbarPlusGui.Name = "TopbarPlus"

local activeItems = Instance.new("Folder")
activeItems.Name = "ActiveItems"
activeItems.Parent = topbarPlusGui

local topbarContainer = Instance.new("Frame")
topbarContainer.BackgroundTransparency = 1
topbarContainer.Name = "TopbarContainer"
topbarContainer.Position = UDim2.new(0, 0, 0, 0)
topbarContainer.Size = UDim2.new(1, 0, 0, 36)
topbarContainer.Visible = true
topbarContainer.ZIndex = 1
topbarContainer.Parent = topbarPlusGui
topbarContainer.Active = false

local iconContainer = Instance.new("Frame")
iconContainer.BackgroundTransparency = 1
iconContainer.Name = "IconContainer"
iconContainer.Position = UDim2.new(0, 104, 0, 4)
iconContainer.Visible = false
iconContainer.ZIndex = 1
iconContainer.Parent = topbarContainer
iconContainer.Active = false

local iconButton = Instance.new("TextButton")
iconButton.Name = "IconButton"
iconButton.Visible = true
iconButton.Text = ""
iconButton.ZIndex = 10--2
iconButton.BorderSizePixel = 0
iconButton.AutoButtonColor = false
iconButton.Parent = iconContainer
iconButton.Active = true

local iconImage = Instance.new("ImageLabel")
iconImage.BackgroundTransparency = 1
iconImage.Name = "IconImage"
iconImage.AnchorPoint = Vector2.new(0, 0.5)
iconImage.Visible = true
iconImage.ZIndex = 11--3
iconImage.ScaleType = Enum.ScaleType.Fit
iconImage.Parent = iconButton
iconImage.Active = false

local iconLabel = Instance.new("TextLabel")
iconLabel.BackgroundTransparency = 1
iconLabel.Name = "IconLabel"
iconLabel.AnchorPoint = Vector2.new(0, 0.5)
iconLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
iconLabel.Text = ""
iconLabel.RichText = true
iconLabel.TextScaled = false
iconLabel.ClipsDescendants = true
iconLabel.ZIndex = 11--3
iconLabel.Parent = iconButton
iconLabel.Active = false

local iconGradient = Instance.new("UIGradient")
iconGradient.Name = "IconGradient"
iconGradient.Enabled = true
iconGradient.Parent = iconButton

local iconCorner = Instance.new("UICorner")
iconCorner.Name = "IconCorner"
iconCorner.Parent = iconButton

local iconOverlay = Instance.new("Frame")
iconOverlay.Name = "IconOverlay"
iconOverlay.BackgroundTransparency = 1
iconOverlay.Position = iconButton.Position
iconOverlay.Size = UDim2.new(1, 0, 1, 0)
iconOverlay.Visible = true
iconOverlay.ZIndex = iconButton.ZIndex + 1
iconOverlay.BorderSizePixel = 0
iconOverlay.Parent = iconContainer
iconOverlay.Active = false

local iconOverlayCorner = iconCorner:Clone()
iconOverlayCorner.Name = "IconOverlayCorner"
iconOverlayCorner.Parent = iconOverlay


-- Notice prompts
local noticeFrame = Instance.new("ImageLabel")
noticeFrame.BackgroundTransparency = 1
noticeFrame.Name = "NoticeFrame"
noticeFrame.Position = UDim2.new(0.45, 0, 0, -2)
noticeFrame.Size = UDim2.new(1, 0, 0.7, 0)
noticeFrame.Visible = true
noticeFrame.ZIndex = 12--4
noticeFrame.ImageTransparency = 1
noticeFrame.ScaleType = Enum.ScaleType.Fit
noticeFrame.Parent = iconButton
noticeFrame.Active = false

local noticeLabel = Instance.new("TextLabel")
noticeLabel.Name = "NoticeLabel"
noticeLabel.BackgroundTransparency = 1
noticeLabel.Position = UDim2.new(0.25, 0, 0.15, 0)
noticeLabel.Size = UDim2.new(0.5, 0, 0.7, 0)
noticeLabel.Visible = true
noticeLabel.ZIndex = 13--5
noticeLabel.Font = Enum.Font.Arial
noticeLabel.Text = "0"
noticeLabel.TextTransparency = 1
noticeLabel.TextScaled = true
noticeLabel.Parent = noticeFrame
noticeLabel.Active = false


-- Captions
local captionContainer = Instance.new("Frame")
captionContainer.Name = "CaptionContainer"
captionContainer.BackgroundTransparency = 1
captionContainer.AnchorPoint = Vector2.new(0, 0)
captionContainer.ClipsDescendants = true
captionContainer.ZIndex = 30
captionContainer.Visible = true
captionContainer.Parent = iconContainer
captionContainer.Active = false

local captionFrame = Instance.new("Frame")
captionFrame.Name = "CaptionFrame"
captionFrame.BorderSizePixel = 0
captionFrame.AnchorPoint = Vector2.new(0.5,0.5)
captionFrame.Position = UDim2.new(0.5,0,0.5,0)
captionFrame.Size = UDim2.new(1,0,1,0)
captionFrame.ZIndex = 31
captionFrame.Parent = captionContainer
captionFrame.Active = false

local captionLabel = Instance.new("TextLabel")
captionLabel.Name = "CaptionLabel"
captionLabel.BackgroundTransparency = 1
captionLabel.AnchorPoint = Vector2.new(0.5,0.5)
captionLabel.Position = UDim2.new(0.5,0,0.56,0)
captionLabel.TextXAlignment = Enum.TextXAlignment.Center
captionLabel.RichText = true
captionLabel.ZIndex = 32
captionLabel.Parent = captionContainer
captionLabel.Active = false

local captionCorner = Instance.new("UICorner")
captionCorner.Name = "CaptionCorner"
captionCorner.Parent = captionFrame

local captionOverlineContainer = Instance.new("Frame")
captionOverlineContainer.Name = "CaptionOverlineContainer"
captionOverlineContainer.BackgroundTransparency = 1
captionOverlineContainer.AnchorPoint = Vector2.new(0.5,0.5)
captionOverlineContainer.Position = UDim2.new(0.5,0,-0.5,3)
captionOverlineContainer.Size = UDim2.new(1,0,1,0)
captionOverlineContainer.ZIndex = 33
captionOverlineContainer.ClipsDescendants = true
captionOverlineContainer.Parent = captionContainer
captionOverlineContainer.Active = false

local captionOverline = Instance.new("Frame")
captionOverline.Name = "CaptionOverline"
captionOverline.AnchorPoint = Vector2.new(0.5,0.5)
captionOverline.Position = UDim2.new(0.5,0,1.5,-3)
captionOverline.Size = UDim2.new(1,0,1,0)
captionOverline.ZIndex = 34
captionOverline.Parent = captionOverlineContainer
captionOverline.Active = false

local captionOverlineCorner = captionCorner:Clone()
captionOverlineCorner.Name = "CaptionOverlineCorner"
captionOverlineCorner.Parent = captionOverline

local captionVisibilityBlocker = captionFrame:Clone()
captionVisibilityBlocker.Name = "CaptionVisibilityBlocker"
captionVisibilityBlocker.BackgroundTransparency = 1
captionVisibilityBlocker.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
captionVisibilityBlocker.ZIndex -= 1
captionVisibilityBlocker.Parent = captionFrame
captionVisibilityBlocker.Active = false

local captionVisibilityCorner = captionVisibilityBlocker.CaptionCorner
captionVisibilityCorner.Name = "CaptionVisibilityCorner"


-- Tips
local tipFrame = Instance.new("Frame")
tipFrame.Name = "TipFrame"
tipFrame.BorderSizePixel = 0
tipFrame.AnchorPoint = Vector2.new(0, 0)
tipFrame.Position = UDim2.new(0,50,0,50)
tipFrame.Size = UDim2.new(1,0,1,-8)
tipFrame.ZIndex = 40
tipFrame.Parent = iconContainer
tipFrame.Active = false

local tipCorner = Instance.new("UICorner")
tipCorner.Name = "TipCorner"
tipCorner.CornerRadius = UDim.new(0.25,0)
tipCorner.Parent = tipFrame

local tipLabel = Instance.new("TextLabel")
tipLabel.Name = "TipLabel"
tipLabel.BackgroundTransparency = 1
tipLabel.TextScaled = false
tipLabel.TextSize = 12
tipLabel.Position = UDim2.new(0,3,0,3)
tipLabel.Size = UDim2.new(1,-6,1,-6)
tipLabel.ZIndex = 41
tipLabel.Parent = tipFrame
tipLabel.Active = false


-- Dropdowns
local dropdownContainer = Instance.new("Frame")
dropdownContainer.Name = "DropdownContainer"
dropdownContainer.BackgroundTransparency = 1
dropdownContainer.BorderSizePixel = 0
dropdownContainer.AnchorPoint = Vector2.new(0.5, 0)
dropdownContainer.ZIndex = -2
dropdownContainer.ClipsDescendants = true
dropdownContainer.Visible = true
dropdownContainer.Parent = iconContainer
dropdownContainer.Active = false

local dropdownFrame = Instance.new("ScrollingFrame")
dropdownFrame.Name = "DropdownFrame"
dropdownFrame.BackgroundTransparency = 1
dropdownFrame.BorderSizePixel = 0
dropdownFrame.AnchorPoint = Vector2.new(0.5, 0)
dropdownFrame.Position = UDim2.new(0.5, 0, 0, 0)
dropdownFrame.Size = UDim2.new(0.5, 2, 1, 0)
dropdownFrame.ZIndex = -1
dropdownFrame.ClipsDescendants = false
dropdownFrame.Visible = true
dropdownFrame.TopImage = dropdownFrame.MidImage
dropdownFrame.BottomImage = dropdownFrame.MidImage
dropdownFrame.VerticalScrollBarInset = Enum.ScrollBarInset.Always
dropdownFrame.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
dropdownFrame.Parent = dropdownContainer
dropdownFrame.Active = false

local dropdownList = Instance.new("UIListLayout")
dropdownList.Name = "DropdownList"
dropdownList.FillDirection = Enum.FillDirection.Vertical
dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
dropdownList.Parent = dropdownFrame

local dropdownPadding = Instance.new("UIPadding")
dropdownPadding.Name = "DropdownPadding"
dropdownPadding.PaddingRight = UDim.new(0, 2)
dropdownPadding.Parent = dropdownFrame


-- Menus
local menuContainer = Instance.new("Frame")
menuContainer.Active = true
menuContainer.Selectable = false
menuContainer.Name = "MenuContainer"
menuContainer.BackgroundTransparency = 1
menuContainer.BorderSizePixel = 0
menuContainer.AnchorPoint = Vector2.new(1, 0)
menuContainer.Size = UDim2.new(0, 500, 0, 50)
menuContainer.ZIndex = -2
menuContainer.ClipsDescendants = true
menuContainer.Visible = true
menuContainer.Parent = iconContainer
menuContainer.Active = false

local menuFrame = Instance.new("ScrollingFrame")
menuFrame.Active = true
menuFrame.Selectable = true
menuFrame.Name = "MenuFrame"
menuFrame.BackgroundTransparency = 1
menuFrame.BorderSizePixel = 0
menuFrame.AnchorPoint = Vector2.new(0, 0)
menuFrame.Position = UDim2.new(0, 0, 0, 0)
menuFrame.Size = UDim2.new(1, 0, 1, 0)
menuFrame.ZIndex = -1 + 10
menuFrame.ClipsDescendants = false
menuFrame.Visible = true
menuFrame.TopImage = ""--menuFrame.MidImage
menuFrame.BottomImage = ""--menuFrame.MidImage
menuFrame.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
menuFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
menuFrame.Parent = menuContainer
menuFrame.Active = false

local menuList = Instance.new("UIListLayout")
menuList.Name = "MenuList"
menuList.FillDirection = Enum.FillDirection.Horizontal
menuList.HorizontalAlignment = Enum.HorizontalAlignment.Right
menuList.SortOrder = Enum.SortOrder.LayoutOrder
menuList.Parent = menuFrame

local menuInvisBlocker = Instance.new("Frame")
menuInvisBlocker.Name = "MenuInvisBlocker"
menuInvisBlocker.BackgroundTransparency = 1
menuInvisBlocker.Size = UDim2.new(0, -2, 1, 0)
menuInvisBlocker.Visible = true
menuInvisBlocker.LayoutOrder = 999999999
menuInvisBlocker.Parent = menuFrame
menuInvisBlocker.Active = false


-- Click Sound
local clickSound = Instance.new("Sound")
clickSound.Name = "ClickSound"
clickSound.Volume = 0
clickSound.Parent = iconContainer


-- Other
local indicator = Instance.new("ImageLabel")
indicator.Name = "Indicator"
indicator.BackgroundTransparency = 1
indicator.Image = "rbxassetid://5278151556"
indicator.Size = UDim2.new(0,32,0,32)
indicator.AnchorPoint = Vector2.new(0.5,0)
indicator.Position = UDim2.new(0.5,0,0,5)
indicator.ScaleType = Enum.ScaleType.Fit
indicator.Visible = false
indicator.Active = true
indicator.Parent = topbarPlusGui
indicator.Active = false



-- PARENT
local localPlayer = game:GetService("Players").LocalPlayer
local playerGui = localPlayer.PlayerGui
topbarPlusGui.Parent = playerGui



return topbarPlusGui</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">TopbarPlusReference</string>
                  <string name="Source">-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local TopbarPlusReference = {}

function TopbarPlusReference.addToReplicatedStorage()
    local existingItem = replicatedStorage:FindFirstChild(script.Name)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
    objectValue.Name = script.Name
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function TopbarPlusReference.getObject()
    local objectValue = replicatedStorage:FindFirstChild(script.Name)
    if objectValue then
        return objectValue
    end
    return false
end

return TopbarPlusReference</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="40">
                <Properties>
                  <string name="Name">VERSION</string>
                  <string name="Source">-- v2.7.5</string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="41">
            <Properties>
              <string name="Name">GuiComponents</string>
            </Properties>
            <Item class="ModuleScript" referent="42">
              <Properties>
                <string name="Name">Blank</string>
                <string name="Source"><![CDATA[local theme = require(script.Parent.Parent.Themes.Current)
local data = require(script.Parent.Parent.Parent.Data)
script.Frame.TextLabel.TextColor3 = theme.BaseText

return function()
	print(data.Shared.CurrentCamera.Model)
	return script.Frame:Clone()
end
]]></string>
              </Properties>
              <Item class="Frame" referent="43">
                <Properties>
                  <string name="Name">Frame</string>
                  <float name="BackgroundTransparency">1</float>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                </Properties>
                <Item class="TextLabel" referent="44">
                  <Properties>
                    <string name="Name">TextLabel</string>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <float name="BackgroundTransparency">1</float>
                    <token name="Font">3</token>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>-50</XO>
                      <YS>1</YS>
                      <YO>-50</YO>
                    </UDim2>
                    <string name="Text">Blank Component</string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">true</bool>
                    <float name="TextSize">14</float>
                    <bool name="TextWrapped">true</bool>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="45">
              <Properties>
                <string name="Name">Cameras</string>
                <string name="Source">return function()
	local copy = script.Frame:Clone()
	
	local focusBox = require(script.Parent.FocusBox)()
	focusBox.Parent = copy.FocusBox
	
	local categoryChooser = require(script.Parent.CategoryChooser)({
		Frames = {
			{
				Name = "Static",
				Frame = require(script.Parent.StaticCameras)(),
				ComponentName = "StaticCameras"
			},
			{
				Name = "Moving",
				Frame = require(script.Parent.MovingCameras)(),
				ComponentName = "MovingCameras"
			},
			{
				Name = "Drones",
				Frame = require(script.Parent.Blank)(),
				ComponentName = "Blank"
			}
		}
	})
	categoryChooser.Parent = copy.Cameras
	
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="46">
                <Properties>
                  <string name="Name">Frame</string>
                  <float name="BackgroundTransparency">1</float>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                </Properties>
                <Item class="Frame" referent="47">
                  <Properties>
                    <string name="Name">FocusBox</string>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>1</Y>
                    </Vector2>
                    <float name="BackgroundTransparency">1</float>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>-3</YO>
                    </UDim2>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>22</YO>
                    </UDim2>
                  </Properties>
                </Item>
                <Item class="Frame" referent="48">
                  <Properties>
                    <string name="Name">Cameras</string>
                    <float name="BackgroundTransparency">1</float>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>-25</YO>
                    </UDim2>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="49">
              <Properties>
                <string name="Name">CategoryChooser</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)
local util = require(script.Parent.Parent.Scripts.Utils)
local window = require(script.Parent.Parent.Scripts.NewWindow)
local ts = game:GetService("TweenService")

export type CategoryChooserTable = {
	Frame: GuiObject,
	Name: string,
	ComponentName: string
}
export type CategoryChooserOptions = {
	Frames: table
}

script.MenuButton.BackgroundColor3 = theme.Base
script.MenuButton.TextColor3 = theme.BaseText
script.Frame.Categories.BackgroundColor3 = theme.Base
script.Frame.Categories.Selector.BackgroundColor3 = theme.Underline

return function(options:CategoryChooserOptions)
	local copy = script.Frame:Clone()
	local buttonWidth = 1/#options.Frames
	copy.Categories.Selector.Size = UDim2.new(buttonWidth,0,0,2)
	for i,v:CategoryChooserTable in pairs(options.Frames) do
		local button = script.MenuButton:Clone()
		button.Text = v.Name
		button.Size = UDim2.fromScale(buttonWidth,1)
		button.Position = UDim2.fromScale((i-1) * buttonWidth,0)
		button.Parent = copy.Categories
		
		button.MouseButton1Click:Connect(function()
			copy.Pages.UIPageLayout:JumpToIndex(i-1)
			ts:Create(copy.Categories.Selector,TweenInfo.new(0.2),{Position = UDim2.fromScale((i-1) * buttonWidth,1)}):Play()
		end)
		button.MouseButton2Click:Connect(function()
			window:new({
				Name = v.ComponentName,
				Title = v.Name,
				Position = UDim2.fromOffset(300,50),
				Enabled = true
			})
		end)
		
		local frame = util:NewInstance("Frame",{
			BackgroundTransparency = 1,
			Size = UDim2.fromScale(1,1),
			LayoutOrder = i,
			Parent = copy.Pages
		})
		v.Frame.Parent = frame
	end
	
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="50">
                <Properties>
                  <string name="Name">Frame</string>
                  <float name="BackgroundTransparency">1</float>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                </Properties>
                <Item class="Frame" referent="51">
                  <Properties>
                    <string name="Name">Pages</string>
                    <float name="BackgroundTransparency">1</float>
                    <bool name="ClipsDescendants">true</bool>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>25</YO>
                    </UDim2>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>-25</YO>
                    </UDim2>
                  </Properties>
                  <Item class="UIPageLayout" referent="52">
                    <Properties>
                      <string name="Name">UIPageLayout</string>
                      <token name="EasingStyle">3</token>
                      <bool name="GamepadInputEnabled">false</bool>
                      <bool name="ScrollWheelInputEnabled">false</bool>
                      <token name="SortOrder">2</token>
                      <bool name="TouchInputEnabled">false</bool>
                      <float name="TweenTime">0.5</float>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Frame" referent="53">
                  <Properties>
                    <string name="Name">Categories</string>
                    <int name="BorderSizePixel">0</int>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>25</YO>
                    </UDim2>
                  </Properties>
                  <Item class="Frame" referent="54">
                    <Properties>
                      <string name="Name">Selector</string>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>1</Y>
                      </Vector2>
                      <int name="BorderSizePixel">0</int>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <int name="ZIndex">2</int>
                    </Properties>
                    <Item class="UICorner" referent="55">
                      <Properties>
                        <string name="Name">UICorner</string>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
              <Item class="TextButton" referent="56">
                <Properties>
                  <string name="Name">MenuButton</string>
                  <int name="BorderSizePixel">0</int>
                  <token name="Font">3</token>
                  <float name="TextSize">15</float>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="57">
              <Properties>
                <string name="Name">Checkbox</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)

script.Frame.TextLabel.TextColor3 = theme.BaseText
script.Frame.Frame.BackgroundColor3 = theme.Base
script.Frame.Frame.TextColor3 = theme.BaseText

export type CheckboxParams = {
	Name: string,
	Checked: boolean
}

return function(params:CheckboxParams)
	local copy = script.Frame:Clone()
	copy.TextLabel.Text = params.Name
	if params.Checked then
		copy.Frame.Text = "✔"
	end
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="58">
                <Properties>
                  <string name="Name">Frame</string>
                  <float name="BackgroundTransparency">1</float>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                </Properties>
                <Item class="TextLabel" referent="59">
                  <Properties>
                    <string name="Name">TextLabel</string>
                    <float name="BackgroundTransparency">1</float>
                    <token name="Font">3</token>
                    <UDim2 name="Size">
                      <XS>0.699999988079071</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <float name="TextSize">15</float>
                    <token name="TextXAlignment">1</token>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="60">
                  <Properties>
                    <string name="Name">Frame</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <token name="Font">3</token>
                    <UDim2 name="Position">
                      <XS>0.8500000238418579</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="Selectable">false</bool>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.800000011920929</YS>
                      <YO>0</YO>
                    </UDim2>
                    <string name="Text"></string>
                  </Properties>
                  <Item class="UIAspectRatioConstraint" referent="61">
                    <Properties>
                      <string name="Name">UIAspectRatioConstraint</string>
                      <token name="DominantAxis">1</token>
                    </Properties>
                  </Item>
                  <Item class="UICorner" referent="62">
                    <Properties>
                      <string name="Name">UICorner</string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="63">
              <Properties>
                <string name="Name">DotSlider</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)
local util = require(script.Parent.Parent.Scripts.Utils)
local data = require(script.Parent.Parent.Scripts.UpdateData)
local uis = game:GetService("UserInputService")
local ts = game:GetService("TweenService")

export type DotSliderParams = {
	Name: string,
	Min: number,
	Max: number,
	Round: number,
	SettingToUpdate: string
}

script.Frame.Reset.BackgroundColor3 = theme.Base
script.Frame.Reset.TextColor3 = theme.BaseText
script.Frame.Namer.TextColor3 = theme.BaseText
script.Frame.Value.TextColor3 = theme.BaseText
script.Frame.Slider.Frame.BackgroundColor3 = theme.BaseDarker
script.Frame.Slider.Frame.Frame.BackgroundColor3 = theme.Base
script.Frame.Slider.Frame.Frame.Frame.BackgroundColor3 = theme.Base

return function(params:DotSliderParams)
	local copy = script.Frame:Clone()
	params.Round = params.Round or 0
	
	copy.Namer.Text = params.Name
	
	copy.Slider.Hitbox.InputBegan:Connect(function(Input:InputObject)
		if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
		local dragging = true
		local stopDrag = Input:GetPropertyChangedSignal("UserInputState"):Connect(function()
			if Input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)

		while dragging do
			local relativePositionX = uis:GetMouseLocation().X - copy.Slider.Frame.AbsolutePosition.X
			local scaleX = math.clamp(relativePositionX / copy.Slider.Frame.AbsoluteSize.X,0,1)
			local value = scaleX * (params.Max - params.Min) + params.Min
			--ts:Create(copy.Slider.Frame.Frame,TweenInfo.new(0.05),{Size = UDim2.fromScale(scaleX,1)}):Play()
			--copy.Slider.Frame.Frame.Size = UDim2.fromScale(scaleX,1)
			--copy.Value.Text = util:Round(value,params.Round)
			data:set(params.SettingToUpdate,value)
			--event:FireServer(value)
			task.wait()
		end

		Input:Destroy()
	end)
	
	local function update()
		local newval = data:get(params.SettingToUpdate)
		local val = util:Map(newval,params.Min,params.Max,0,1)
		ts:Create(copy.Slider.Frame.Frame,TweenInfo.new(0.05),{Size = UDim2.fromScale(val,1)}):Play()
		copy.Value.Text = util:Round(newval,params.Round)
	end
	update()
	data:onChange(params.SettingToUpdate,update)

	--event.OnClientEvent:Connect(function(val)
	--	sliderFrame.Background.Slider.Size = UDim2.fromScale(util:Map(val,min,max,0,1),1)
	--	sliderFrame.Value.Text = util:Round(val,round)
	--end)

	--sliderFrame.Reset.MouseButton1Click:Connect(function()
	--	event:FireServer(default)
	--end)
	
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="64">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="65">
                  <Properties>
                    <string name="Name">Slider</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>0</G>
                      <B>0.01568627543747425</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.8500000238418579</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.8500000238418579</XS>
                      <XO>0</XO>
                      <YS>0.15000000596046448</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="Frame" referent="66">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.7098039388656616</R>
                        <G>0.7098039388656616</G>
                        <B>0.7098039388656616</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UICorner" referent="67">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <UDim name="CornerRadius">
                          <S>0</S>
                          <O>10</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags">
                        </BinaryString>
                      </Properties>
                    </Item>
                    <Item class="Frame" referent="68">
                      <Properties>
                        <string name="Name">Frame</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">0</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                      <Item class="UICorner" referent="69">
                        <Properties>
                          <string name="Name">UICorner</string>
                          <BinaryString name="AttributesSerialize">
                          </BinaryString>
                          <UDim name="CornerRadius">
                            <S>0</S>
                            <O>10</O>
                          </UDim>
                          <int64 name="SourceAssetId">-1</int64>
                          <BinaryString name="Tags">
                          </BinaryString>
                        </Properties>
                      </Item>
                      <Item class="Frame" referent="70">
                        <Properties>
                          <string name="Name">Frame</string>
                          <bool name="Active">false</bool>
                          <Vector2 name="AnchorPoint">
                            <X>0.5</X>
                            <Y>0.5</Y>
                          </Vector2>
                          <BinaryString name="AttributesSerialize">
                          </BinaryString>
                          <bool name="AutoLocalize">true</bool>
                          <token name="AutomaticSize">0</token>
                          <Color3 name="BackgroundColor3">
                            <R>1</R>
                            <G>1</G>
                            <B>1</B>
                          </Color3>
                          <float name="BackgroundTransparency">0</float>
                          <Color3 name="BorderColor3">
                            <R>0.10588236153125763</R>
                            <G>0.16470588743686676</G>
                            <B>0.20784315466880798</B>
                          </Color3>
                          <token name="BorderMode">0</token>
                          <int name="BorderSizePixel">1</int>
                          <bool name="ClipsDescendants">false</bool>
                          <bool name="Draggable">false</bool>
                          <int name="LayoutOrder">0</int>
                          <Ref name="NextSelectionDown">null</Ref>
                          <Ref name="NextSelectionLeft">null</Ref>
                          <Ref name="NextSelectionRight">null</Ref>
                          <Ref name="NextSelectionUp">null</Ref>
                          <UDim2 name="Position">
                            <XS>1</XS>
                            <XO>0</XO>
                            <YS>0.5</YS>
                            <YO>0</YO>
                          </UDim2>
                          <Ref name="RootLocalizationTable">null</Ref>
                          <float name="Rotation">0</float>
                          <bool name="Selectable">false</bool>
                          <Ref name="SelectionImageObject">null</Ref>
                          <UDim2 name="Size">
                            <XS>0</XS>
                            <XO>20</XO>
                            <YS>0</YS>
                            <YO>20</YO>
                          </UDim2>
                          <token name="SizeConstraint">0</token>
                          <int64 name="SourceAssetId">-1</int64>
                          <token name="Style">0</token>
                          <BinaryString name="Tags">
                          </BinaryString>
                          <bool name="Visible">true</bool>
                          <int name="ZIndex">1</int>
                        </Properties>
                        <Item class="UICorner" referent="71">
                          <Properties>
                            <string name="Name">UICorner</string>
                            <BinaryString name="AttributesSerialize">
                            </BinaryString>
                            <UDim name="CornerRadius">
                              <S>1</S>
                              <O>0</O>
                            </UDim>
                            <int64 name="SourceAssetId">-1</int64>
                            <BinaryString name="Tags">
                            </BinaryString>
                          </Properties>
                        </Item>
                      </Item>
                    </Item>
                  </Item>
                  <Item class="Frame" referent="72">
                    <Properties>
                      <string name="Name">Hitbox</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0.5</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>0</G>
                        <B>0</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>20</XO>
                        <YS>1</YS>
                        <YO>8</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                  </Item>
                </Item>
                <Item class="TextLabel" referent="73">
                  <Properties>
                    <string name="Name">Namer</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0.10000000149011612</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.4000000059604645</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Name</string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">14</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">1</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="TextLabel" referent="74">
                  <Properties>
                    <string name="Name">Value</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">4</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.10000000149011612</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.4000000059604645</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">0</string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">20</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="75">
                  <Properties>
                    <string name="Name">Reset</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>1</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">true</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.8999999761581421</XS>
                      <XO>0</XO>
                      <YS>0.15000000596046448</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.30000001192092896</XS>
                      <XO>0</XO>
                      <YS>0.4000000059604645</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Reset</string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">16</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="76">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>8</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="77">
              <Properties>
                <string name="Name">FocusBox</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)

script.FocusBox.UsernameBox.BackgroundColor3 = theme.DarkerButton
script.FocusBox.Focus.BackgroundColor3 = theme.DarkerButton
script.FocusBox.StopFocus.BackgroundColor3 = theme.DarkerButton

return function()
	return script.FocusBox:Clone()
end</string>
              </Properties>
              <Item class="Frame" referent="78">
                <Properties>
                  <string name="Name">FocusBox</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="TextBox" referent="79">
                  <Properties>
                    <string name="Name">UsernameBox</string>
                    <bool name="Active">true</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.23137255012989044</R>
                      <G>0.23137255012989044</G>
                      <B>0.23137255012989044</B>
                    </Color3>
                    <float name="BackgroundTransparency">0.5</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClearTextOnFocus">true</bool>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="MultiLine">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <Color3 name="PlaceholderColor3">
                      <R>0.699999988079071</R>
                      <G>0.699999988079071</G>
                      <B>0.699999988079071</B>
                    </Color3>
                    <string name="PlaceholderText">Username</string>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">true</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <bool name="ShowNativeInput">true</bool>
                    <UDim2 name="Size">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text"></string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextEditable">true</bool>
                    <bool name="TextScaled">true</bool>
                    <float name="TextSize">14</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">true</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="80">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>8</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="TextButton" referent="81">
                  <Properties>
                    <string name="Name">Focus</string>
                    <bool name="Active">true</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">true</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.23137255012989044</R>
                      <G>0.23137255012989044</G>
                      <B>0.23137255012989044</B>
                    </Color3>
                    <float name="BackgroundTransparency">0.5</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">true</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.20000000298023224</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Focus</string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">14</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="82">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>8</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="UIListLayout" referent="83">
                  <Properties>
                    <string name="Name">UIListLayout</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <token name="FillDirection">0</token>
                    <token name="HorizontalAlignment">0</token>
                    <UDim name="Padding">
                      <S>0.029999999329447746</S>
                      <O>0</O>
                    </UDim>
                    <token name="SortOrder">2</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <token name="VerticalAlignment">0</token>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="84">
                  <Properties>
                    <string name="Name">StopFocus</string>
                    <bool name="Active">true</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">true</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.23137255012989044</R>
                      <G>0.23137255012989044</G>
                      <B>0.23137255012989044</B>
                    </Color3>
                    <float name="BackgroundTransparency">0.5</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">true</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.20000000298023224</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Stop</string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">14</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="85">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>8</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="86">
              <Properties>
                <string name="Name">GlobalSettings</string>
                <string name="Source">local dotslider = require(script.Parent.DotSlider)

return function()
	local copy = script.Frame:Clone()
	--dotslider({Name = "Bar size", Min = 0, Max = 50, Round = 0}).Parent = copy.SomeSlider
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="87">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="88">
                  <Properties>
                    <string name="Name">SomeSlider</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>50</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="89">
              <Properties>
                <string name="Name">LocalSettings</string>
                <string name="Source">local dotslider = require(script.Parent.DotSlider)
local switch = require(script.Parent.Switch)
local smoothGrid = require(script.Parent.Parent.Scripts.SmoothGrid)

return function()
	local copy = script.Frame:Clone()
	switch({Name = "Transparent blackout:", SettingToUpdate = "Local.Settings.TransparentBlackout"}).Parent = copy.TopSwitches.TransparentBlackout
	switch({Name = "Keybinds:", SettingToUpdate = "Local.Settings.Keybinds"}).Parent = copy.TopSwitches.Keybinds
	dotslider({Name = "Drone Speed", Min = 0, Max = 2, Round = 2, SettingToUpdate = "Local.Settings.DroneSpeed"}).Parent = copy.SomeSlider
	smoothGrid(copy.TopSwitches,copy.TopSwitches.UIGridLayout)
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="90">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="91">
                  <Properties>
                    <string name="Name">SomeSlider</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>60</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>50</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="Frame" referent="92">
                  <Properties>
                    <string name="Name">TopSwitches</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>60</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIGridLayout" referent="93">
                    <Properties>
                      <string name="Name">UIGridLayout</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim2 name="CellPadding">
                        <XS>0</XS>
                        <XO>5</XO>
                        <YS>0</YS>
                        <YO>5</YO>
                      </UDim2>
                      <UDim2 name="CellSize">
                        <XS>0</XS>
                        <XO>220</XO>
                        <YS>0</YS>
                        <YO>30</YO>
                      </UDim2>
                      <token name="FillDirection">0</token>
                      <int name="FillDirectionMaxCells">0</int>
                      <token name="HorizontalAlignment">0</token>
                      <token name="SortOrder">2</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="StartCorner">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <token name="VerticalAlignment">1</token>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="94">
                    <Properties>
                      <string name="Name">Keybinds</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>30</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>30</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="95">
                    <Properties>
                      <string name="Name">TransparentBlackout</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>30</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="96">
              <Properties>
                <string name="Name">MovingCameras</string>
                <string name="Source">local util = require(script.Parent.Parent.Scripts.Other)
local cameras = workspace:FindFirstChild("CameraSystem").Cameras.Moving

return function()
	local copy = script.Moving:Clone()
	util:generateButtonsForFolder(cameras,copy.Frame,"Moving")
	return copy
end</string>
              </Properties>
              <Item class="ScrollingFrame" referent="97">
                <Properties>
                  <string name="Name">Moving</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticCanvasSize">2</token>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">0</int>
                  <Content name="BottomImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url>
                  </Content>
                  <Vector2 name="CanvasPosition">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <UDim2 name="CanvasSize">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>2</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="ElasticBehavior">0</token>
                  <token name="HorizontalScrollBarInset">0</token>
                  <int name="LayoutOrder">0</int>
                  <Content name="MidImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-middle.png</url>
                  </Content>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <Color3 name="ScrollBarImageColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="ScrollBarImageTransparency">0</float>
                  <int name="ScrollBarThickness">5</int>
                  <token name="ScrollingDirection">4</token>
                  <bool name="ScrollingEnabled">true</bool>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="TopImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-top.png</url>
                  </Content>
                  <token name="VerticalScrollBarInset">0</token>
                  <token name="VerticalScrollBarPosition">0</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="98">
                  <Properties>
                    <string name="Name">Frame</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">2</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>-5</XO>
                      <YS>1</YS>
                      <YO>-5</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIListLayout" referent="99">
                    <Properties>
                      <string name="Name">UIListLayout</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <token name="FillDirection">1</token>
                      <token name="HorizontalAlignment">1</token>
                      <UDim name="Padding">
                        <S>0</S>
                        <O>0</O>
                      </UDim>
                      <token name="SortOrder">2</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <token name="VerticalAlignment">1</token>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="100">
              <Properties>
                <string name="Name">RoundedButton</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)

script.CameraButtonTemplate.BackgroundColor3 = theme.Base
script.CameraButtonTemplate.TextColor3 = theme.BaseText

return function(name:string)
	local copy = script.CameraButtonTemplate:Clone()
	copy.Text = name
	return copy
end</string>
              </Properties>
              <Item class="TextButton" referent="101">
                <Properties>
                  <string name="Name">CameraButtonTemplate</string>
                  <bool name="Active">true</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoButtonColor">true</bool>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>0.25882354378700256</R>
                    <G>0.25882354378700256</G>
                    <B>0.25882354378700256</B>
                  </Color3>
                  <float name="BackgroundTransparency">0</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="Font">3</token>
                  <int name="LayoutOrder">0</int>
                  <float name="LineHeight">1</float>
                  <int name="MaxVisibleGraphemes">-1</int>
                  <bool name="Modal">false</bool>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="RichText">false</bool>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">true</bool>
                  <bool name="Selected">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>0</XS>
                    <XO>200</XO>
                    <YS>0</YS>
                    <YO>50</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <string name="Text">Button</string>
                  <Color3 name="TextColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <bool name="TextScaled">false</bool>
                  <float name="TextSize">15</float>
                  <Color3 name="TextStrokeColor3">
                    <R>0</R>
                    <G>0</G>
                    <B>0</B>
                  </Color3>
                  <float name="TextStrokeTransparency">1</float>
                  <float name="TextTransparency">0</float>
                  <token name="TextTruncate">0</token>
                  <bool name="TextWrapped">true</bool>
                  <token name="TextXAlignment">2</token>
                  <token name="TextYAlignment">1</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UICorner" referent="102">
                  <Properties>
                    <string name="Name">UICorner</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <UDim name="CornerRadius">
                      <S>0</S>
                      <O>8</O>
                    </UDim>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="103">
              <Properties>
                <string name="Name">Settings</string>
                <string name="Source">return function()
	local copy = script.Frame:Clone()
	
	local categoryChooser = require(script.Parent.CategoryChooser)({
		Frames = {
			{
				Name = "Local",
				Frame = require(script.Parent.LocalSettings)(),
				ComponentName = "LocalSettings"
			},
			{
				Name = "Global",
				Frame = require(script.Parent.GlobalSettings)(),
				ComponentName = "GlobalSettings"
			}
		}
	})
	categoryChooser.Parent = copy
	
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="104">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="105">
              <Properties>
                <string name="Name">Slider</string>
                <string name="Source">return function()
	return script.Frame:Clone()
end</string>
              </Properties>
              <Item class="Frame" referent="106">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0.5</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>0.8999999761581421</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="107">
                  <Properties>
                    <string name="Name">Frame</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.7098039388656616</R>
                      <G>0.7098039388656616</G>
                      <B>0.7098039388656616</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="108">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>10</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="109">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>0.5</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UICorner" referent="110">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <UDim name="CornerRadius">
                          <S>0</S>
                          <O>10</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags">
                        </BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="111">
              <Properties>
                <string name="Name">StaticCameras</string>
                <string name="Source">local util = require(script.Parent.Parent.Scripts.Other)
local cameras = workspace:FindFirstChild("CameraSystem").Cameras.Static

return function()
	local copy = script.Static:Clone()
	util:generateButtonsForFolder(cameras,copy.Frame,"Static")
	return copy
end</string>
              </Properties>
              <Item class="ScrollingFrame" referent="112">
                <Properties>
                  <string name="Name">Static</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticCanvasSize">2</token>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">0</int>
                  <Content name="BottomImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url>
                  </Content>
                  <Vector2 name="CanvasPosition">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <UDim2 name="CanvasSize">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>2</YS>
                    <YO>0</YO>
                  </UDim2>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <token name="ElasticBehavior">0</token>
                  <token name="HorizontalScrollBarInset">0</token>
                  <int name="LayoutOrder">0</int>
                  <Content name="MidImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-middle.png</url>
                  </Content>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <Color3 name="ScrollBarImageColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="ScrollBarImageTransparency">0</float>
                  <int name="ScrollBarThickness">5</int>
                  <token name="ScrollingDirection">4</token>
                  <bool name="ScrollingEnabled">true</bool>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="TopImage">
                    <url>rbxasset://textures/ui/Scroll/scroll-top.png</url>
                  </Content>
                  <token name="VerticalScrollBarInset">0</token>
                  <token name="VerticalScrollBarPosition">0</token>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="Frame" referent="113">
                  <Properties>
                    <string name="Name">Frame</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0.5</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">2</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.5</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>-5</XO>
                      <YS>1</YS>
                      <YO>-5</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UIListLayout" referent="114">
                    <Properties>
                      <string name="Name">UIListLayout</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <token name="FillDirection">1</token>
                      <token name="HorizontalAlignment">1</token>
                      <UDim name="Padding">
                        <S>0</S>
                        <O>0</O>
                      </UDim>
                      <token name="SortOrder">2</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <token name="VerticalAlignment">1</token>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="115">
              <Properties>
                <string name="Name">Switch</string>
                <string name="Source">local theme = require(script.Parent.Parent.Themes.Current)
local ts = game:GetService("TweenService")
local data = require(script.Parent.Parent.Scripts.UpdateData)

script.Frame.TextLabel.TextColor3 = theme.BaseText
script.Frame.Frame.BackgroundColor3 = theme.BaseDarker
script.Frame.Frame.Frame.BackgroundColor3 = theme.BaseDarker2
script.Frame.Frame.TextColor3 = theme.BaseText

export type CheckboxParams = {
	Name: string,
	Checked: boolean,
	SettingToUpdate: string
}

return function(params:CheckboxParams)
	local copy = script.Frame:Clone()
	copy.TextLabel.Text = params.Name
	local function updateColors()
		local position = UDim2.fromScale(0.95,0.5)
		local anchorpoint = Vector2.new(1,0.5)
		local ffbackground = theme.Underline
		local fbackground = theme.Base
		if not data:get(params.SettingToUpdate) then
			position = UDim2.fromScale(0.05,0.5)
			anchorpoint = Vector2.new(0,0.5)
			ffbackground = theme.BaseDarker2
			fbackground = theme.BaseDarker
		end
		ts:Create(copy.Frame.Frame,TweenInfo.new(0.2),{Position = position, AnchorPoint = anchorpoint, BackgroundColor3 = ffbackground}):Play()
		ts:Create(copy.Frame,TweenInfo.new(0.2),{BackgroundColor3 = fbackground}):Play()
	end
	updateColors()
	copy.Frame.MouseButton1Click:Connect(function()
		data:set(params.SettingToUpdate,not data:get(params.SettingToUpdate))
	end)
	data:onChange(params.SettingToUpdate,function(newval)
		updateColors()
	end)
	return copy
end</string>
              </Properties>
              <Item class="Frame" referent="116">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>1</XS>
                    <XO>0</XO>
                    <YS>1</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="TextLabel" referent="117">
                  <Properties>
                    <string name="Name">TextLabel</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.699999988079071</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Label</string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">15</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">1</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="118">
                  <Properties>
                    <string name="Name">Frame</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0.5</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">true</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.7098039388656616</R>
                      <G>0.7098039388656616</G>
                      <B>0.7098039388656616</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">3</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0.699999988079071</XS>
                      <XO>5</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.699999988079071</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text"></string>
                    <Color3 name="TextColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">15</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">true</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="UICorner" referent="119">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>1</S>
                        <O>0</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                  <Item class="Frame" referent="120">
                    <Properties>
                      <string name="Name">Frame</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0.5</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.5411764979362488</R>
                        <G>0.5411764979362488</G>
                        <B>0.5411764979362488</B>
                      </Color3>
                      <float name="BackgroundTransparency">0</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0.05000000074505806</XS>
                        <XO>0</XO>
                        <YS>0.5</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>0.699999988079071</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="UIAspectRatioConstraint" referent="121">
                      <Properties>
                        <string name="Name">UIAspectRatioConstraint</string>
                        <float name="AspectRatio">1</float>
                        <token name="AspectType">0</token>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <token name="DominantAxis">1</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags">
                        </BinaryString>
                      </Properties>
                    </Item>
                    <Item class="UICorner" referent="122">
                      <Properties>
                        <string name="Name">UICorner</string>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <UDim name="CornerRadius">
                          <S>1</S>
                          <O>0</O>
                        </UDim>
                        <int64 name="SourceAssetId">-1</int64>
                        <BinaryString name="Tags">
                        </BinaryString>
                      </Properties>
                    </Item>
                  </Item>
                  <Item class="UIAspectRatioConstraint" referent="123">
                    <Properties>
                      <string name="Name">UIAspectRatioConstraint</string>
                      <float name="AspectRatio">2</float>
                      <token name="AspectType">0</token>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <token name="DominantAxis">1</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="124">
            <Properties>
              <string name="Name">Scripts</string>
            </Properties>
            <Item class="ModuleScript" referent="125">
              <Properties>
                <string name="Name">CameraController</string>
                <string name="Source">local controller = {}
local replicatedStorage = game:GetService("ReplicatedStorage")
local run = game:GetService("RunService")
local replicated = replicatedStorage:WaitForChild("CameraSystem")
local topbarPlusReference = replicatedStorage:FindFirstChild("TopbarPlusReference")
local iconModule = replicated.Client.Dependencies.TopbarPlus
local api = require(workspace:WaitForChild("CameraSystem"):WaitForChild("Api"))
local directData = require(replicated.Data)
local cameraInstance = workspace.CurrentCamera

local function controlLoop()
    local cameraType = directData.Shared.CurrentCamera.Type
	local cameraModel = directData.Shared.CurrentCamera.Model
	if cameraType == "Default" then
		directData.Shared.CameraData.Position = api:GetDefaultCamPosition().Position
	elseif cameraType == "Static" then
		directData.Shared.CameraData.Position = cameraModel.Position
		directData.Shared.CameraData.Rotation = cameraModel.Orientation
	end
end

local function watchLoop()
	local rot = directData.Shared.CameraData.Rotation
	directData.Shared.CameraData.CFrame = CFrame.new(directData.Shared.CameraData.Position) * CFrame.Angles(math.rad(rot.X),math.rad(rot.Y),math.rad(rot.Z))

	if cameraInstance.CameraType ~= Enum.CameraType.Scriptable then
		cameraInstance.CameraType = Enum.CameraType.Scriptable
	end
	cameraInstance.CFrame = directData.Shared.CameraData.CFrame
end

if topbarPlusReference then
	iconModule = topbarPlusReference.Value
end
local Icon = require(iconModule)
local watchButton = Icon.new():setLabel("Watch"):setMid():setLabel("Exit","selected"):setSize(100,32)
watchButton.selected:Connect(function()
	run:BindToRenderStep("CameraSystemWatchLoop", Enum.RenderPriority.Camera.Value - 1, watchLoop)
end)
watchButton.deselected:Connect(function()
	run:UnbindFromRenderStep("CameraSystemWatchLoop")
    cameraInstance.CameraType = Enum.CameraType.Custom
end)

run.Heartbeat:Connect(controlLoop)

function controller:Watch()
    watchButton:select()
end

function controller:Unwatch()
    watchButton:deselect()
end

return controller</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="126">
              <Properties>
                <string name="Name">DraggableUI</string>
                <string name="Source">local UserInputService = game:GetService("UserInputService")
local players = game:GetService("Players")
local mouse = players.LocalPlayer:GetMouse()
local ICONS = {
	horizontal = "rbxassetid://7655080017",
	vertical = "rbxassetid://7655095494",
	bottomLeft = "rbxassetid://7655124995",
	bottomRight = "rbxassetid://7655117647"
}
local ROBLOX_TOPBAR_SIZE = 36
local TOPBAR_SIZE = 20

--// https://devforum.roblox.com/t/--/107689/5
return function(gui)
	local dragging
	local dragInput
	local dragStart
	local startPos

	local function update(input)
	local delta = input.Position - dragStart
		gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end

	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)

	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
	
	local MINIMUM_HEIGHT = gui.Content.AbsoluteSize.Y
	local MINIMUM_WIDTH = gui.AbsoluteSize.X
	local resizing = nil
	local lastCursor = mouse.Icon
	local function startResize(input,side)
		if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
		local draggingResize = true
		resizing = true
		local startingPosition = input.Position
		local startingSize = gui.Size
		local startingContentSize = gui.Content.Size
		local startingFramePosition = gui.Position
		local stopDrag = input:GetPropertyChangedSignal("UserInputState"):Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				draggingResize = false
				resizing = nil
				mouse.Icon = lastCursor
			end
		end)

		while draggingResize do
			if side == "right" then
				local diff = UserInputService:GetMouseLocation().X - startingPosition.X
				gui.Size = UDim2.fromOffset(math.max(startingSize.X.Offset + diff,MINIMUM_WIDTH), TOPBAR_SIZE)
			elseif side == "bottom" then
				local diff = UserInputService:GetMouseLocation().Y - startingPosition.Y
				gui.Content.Size = UDim2.new(1,0,0,math.max(startingContentSize.Y.Offset + diff - ROBLOX_TOPBAR_SIZE,MINIMUM_HEIGHT))
			elseif side == "left" then
				local diff = startingPosition.X - UserInputService:GetMouseLocation().X
				if startingSize.X.Offset + diff > MINIMUM_WIDTH then
					gui.Size = UDim2.fromOffset(math.max(startingSize.X.Offset + diff,MINIMUM_WIDTH), TOPBAR_SIZE)
					gui.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X,startingFramePosition.Y.Offset)
				end
			elseif side == "bottomleft" then
				local Xdiff = startingPosition.X - UserInputService:GetMouseLocation().X
				local Ydiff = UserInputService:GetMouseLocation().Y - startingPosition.Y
				gui.Content.Size = UDim2.new(1,0,0,math.max(startingContentSize.Y.Offset + Ydiff - ROBLOX_TOPBAR_SIZE,MINIMUM_HEIGHT))
				if startingSize.X.Offset + Xdiff > MINIMUM_WIDTH then
					gui.Size = UDim2.fromOffset(math.max(startingSize.X.Offset + Xdiff,MINIMUM_WIDTH), TOPBAR_SIZE)
					gui.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X,startingFramePosition.Y.Offset)
				end
			elseif side == "bottomright" then
				local Xdiff = UserInputService:GetMouseLocation().X - startingPosition.X
				local Ydiff = UserInputService:GetMouseLocation().Y - startingPosition.Y
				gui.Content.Size = UDim2.new(1,0,0,math.max(startingContentSize.Y.Offset + Ydiff - ROBLOX_TOPBAR_SIZE,MINIMUM_HEIGHT))
				gui.Size = UDim2.fromOffset(math.max(startingSize.X.Offset + Xdiff,MINIMUM_WIDTH), TOPBAR_SIZE)
			end
			task.wait()
		end
	end

	gui.Content.Drag.Right.InputBegan:Connect(function(input:InputObject)
		startResize(input,"right")
	end)
	gui.Content.Drag.Right.MouseEnter:Connect(function()
		if not resizing then
			lastCursor = mouse.Icon
			mouse.Icon = ICONS.horizontal
		end
	end)
	gui.Content.Drag.Right.MouseLeave:Connect(function()
		if not resizing then
			mouse.Icon = ""
		end
	end)
	
	gui.Content.Drag.Left.InputBegan:Connect(function(input:InputObject)
		startResize(input,"left")
	end)

	gui.Content.Drag.Left.MouseEnter:Connect(function()
		if not resizing then
			lastCursor = mouse.Icon
			mouse.Icon = ICONS.horizontal
		end
	end)
	gui.Content.Drag.Left.MouseLeave:Connect(function()
		if not resizing then
			mouse.Icon = ""
		end
	end)
	
	gui.Content.Drag.Bottom.InputBegan:Connect(function(input:InputObject)
		startResize(input,"bottom")
	end)
	gui.Content.Drag.Bottom.MouseEnter:Connect(function()
		if not resizing then
			lastCursor = mouse.Icon
			mouse.Icon = ICONS.vertical
		end
	end)
	gui.Content.Drag.Bottom.MouseLeave:Connect(function()
		if not resizing then
			mouse.Icon = ""
		end
	end)
	
	gui.Content.Drag.BottomLeft.InputBegan:Connect(function(input:InputObject)
		startResize(input,"bottomleft")
	end)
	gui.Content.Drag.BottomLeft.MouseEnter:Connect(function()
		if not resizing then
			lastCursor = mouse.Icon
			mouse.Icon = ICONS.bottomLeft
		end
	end)
	gui.Content.Drag.BottomLeft.MouseLeave:Connect(function()
		if not resizing then
			mouse.Icon = ""
		end
	end)
	
	gui.Content.Drag.BottomRight.InputBegan:Connect(function(input:InputObject)
		startResize(input,"bottomright")
	end)
	gui.Content.Drag.BottomRight.MouseEnter:Connect(function()
		if not resizing then
			lastCursor = mouse.Icon
			mouse.Icon = ICONS.bottomRight
		end
	end)
	gui.Content.Drag.BottomRight.MouseLeave:Connect(function()
		if not resizing then
			mouse.Icon = ""
		end
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="127">
              <Properties>
                <string name="Name">NewWindow</string>
                <string name="Source">local utils = require(script.Parent.Utils)
local theme = require(script.Parent.Parent.Themes.Current)
local draggableUi = require(script.Parent.DraggableUI)
local window = {}
local parent

export type NewWindowParams = {
	Title: string,
	Name: string,
	MinimumWidth: number,
	MinimumHeight: number,
	Position: UDim2,
	Enabled: boolean
}

function window:setParent(instance)
	parent = instance
end

script.Frame.BackgroundColor3 = theme.Base
script.Frame.CloseButtonOverlay1.BackgroundColor3 = theme.RedButton
script.Frame.CloseButtonOverlay2.BackgroundColor3 = theme.RedButton
script.Frame.Close.BackgroundColor3 = theme.RedButton
script.Frame.Minimise.BackgroundColor3 = theme.DarkerButton
script.Frame.TopbarFiller.BackgroundColor3 = theme.Base
script.Frame.Content.Content.BackgroundColor3 = theme.Base
script.Frame.TextLabel.TextColor3 = theme.BaseText
script.Frame.Content.Content.BorderColor3 = theme.BaseBorder

function window:new(params:NewWindowParams,options)
	local minWidth = params.MinimumWidth or 220
	local minHeight = params.MinimumHeight or 300
	local pos = params.Position or UDim2.fromOffset(200,50)
	local windowCopy = script.Frame:Clone()
	windowCopy.Name = params.Name
	windowCopy.Size = UDim2.fromOffset(minWidth,20)
	windowCopy.Content.Size = UDim2.new(1,0,0,minHeight)
	windowCopy.Position = pos
	windowCopy.Visible = params.Enabled or false
	windowCopy.TextLabel.Text = params.Title
	
	windowCopy.Close.MouseButton1Click:Connect(function()
		windowCopy:Destroy()
	end)
	
	local content = require(script.Parent.Parent.GuiComponents[params.Name])(params,options)
	content.Parent = windowCopy.Content.Content
	windowCopy.Parent = parent
	draggableUi(windowCopy)
	return windowCopy
end

return window</string>
              </Properties>
              <Item class="Frame" referent="128">
                <Properties>
                  <string name="Name">Frame</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>0.25882354378700256</R>
                    <G>0.25882354378700256</G>
                    <B>0.25882354378700256</B>
                  </Color3>
                  <float name="BackgroundTransparency">0</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>200</XO>
                    <YS>0</YS>
                    <YO>50</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>0</XS>
                    <XO>220</XO>
                    <YS>0</YS>
                    <YO>20</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UICorner" referent="129">
                  <Properties>
                    <string name="Name">UICorner</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <UDim name="CornerRadius">
                      <S>0</S>
                      <O>10</O>
                    </UDim>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                  </Properties>
                </Item>
                <Item class="Frame" referent="130">
                  <Properties>
                    <string name="Name">TopbarFiller</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.25882354378700256</R>
                      <G>0.25882354378700256</G>
                      <B>0.25882354378700256</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0.5</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="Frame" referent="131">
                  <Properties>
                    <string name="Name">Content</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.25882354378700256</R>
                      <G>0.25882354378700256</G>
                      <B>0.25882354378700256</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.0784313753247261</R>
                      <G>0.0784313753247261</G>
                      <B>0.0784313753247261</B>
                    </Color3>
                    <token name="BorderMode">2</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>300</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                  <Item class="Frame" referent="132">
                    <Properties>
                      <string name="Name">Drag</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>1</R>
                        <G>1</G>
                        <B>1</B>
                      </Color3>
                      <float name="BackgroundTransparency">1</float>
                      <Color3 name="BorderColor3">
                        <R>0.10588236153125763</R>
                        <G>0.16470588743686676</G>
                        <B>0.20784315466880798</B>
                      </Color3>
                      <token name="BorderMode">0</token>
                      <int name="BorderSizePixel">1</int>
                      <bool name="ClipsDescendants">false</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                    <Item class="Frame" referent="133">
                      <Properties>
                        <string name="Name">Left</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>7</XO>
                          <YS>1</YS>
                          <YO>-10</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="Frame" referent="134">
                      <Properties>
                        <string name="Name">Right</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>0</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>7</XO>
                          <YS>1</YS>
                          <YO>-10</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="Frame" referent="135">
                      <Properties>
                        <string name="Name">Bottom</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0.5</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>1</XS>
                          <XO>-20</XO>
                          <YS>0</YS>
                          <YO>7</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="Frame" referent="136">
                      <Properties>
                        <string name="Name">BottomLeft</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>0</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>15</XO>
                          <YS>0</YS>
                          <YO>15</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                    <Item class="Frame" referent="137">
                      <Properties>
                        <string name="Name">BottomRight</string>
                        <bool name="Active">false</bool>
                        <Vector2 name="AnchorPoint">
                          <X>0.5</X>
                          <Y>0.5</Y>
                        </Vector2>
                        <BinaryString name="AttributesSerialize">
                        </BinaryString>
                        <bool name="AutoLocalize">true</bool>
                        <token name="AutomaticSize">0</token>
                        <Color3 name="BackgroundColor3">
                          <R>1</R>
                          <G>1</G>
                          <B>1</B>
                        </Color3>
                        <float name="BackgroundTransparency">1</float>
                        <Color3 name="BorderColor3">
                          <R>0.10588236153125763</R>
                          <G>0.16470588743686676</G>
                          <B>0.20784315466880798</B>
                        </Color3>
                        <token name="BorderMode">0</token>
                        <int name="BorderSizePixel">1</int>
                        <bool name="ClipsDescendants">false</bool>
                        <bool name="Draggable">false</bool>
                        <int name="LayoutOrder">0</int>
                        <Ref name="NextSelectionDown">null</Ref>
                        <Ref name="NextSelectionLeft">null</Ref>
                        <Ref name="NextSelectionRight">null</Ref>
                        <Ref name="NextSelectionUp">null</Ref>
                        <UDim2 name="Position">
                          <XS>1</XS>
                          <XO>0</XO>
                          <YS>1</YS>
                          <YO>0</YO>
                        </UDim2>
                        <Ref name="RootLocalizationTable">null</Ref>
                        <float name="Rotation">0</float>
                        <bool name="Selectable">false</bool>
                        <Ref name="SelectionImageObject">null</Ref>
                        <UDim2 name="Size">
                          <XS>0</XS>
                          <XO>15</XO>
                          <YS>0</YS>
                          <YO>15</YO>
                        </UDim2>
                        <token name="SizeConstraint">0</token>
                        <int64 name="SourceAssetId">-1</int64>
                        <token name="Style">0</token>
                        <BinaryString name="Tags">
                        </BinaryString>
                        <bool name="Visible">true</bool>
                        <int name="ZIndex">1</int>
                      </Properties>
                    </Item>
                  </Item>
                  <Item class="Frame" referent="138">
                    <Properties>
                      <string name="Name">Content</string>
                      <bool name="Active">false</bool>
                      <Vector2 name="AnchorPoint">
                        <X>0</X>
                        <Y>0</Y>
                      </Vector2>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <bool name="AutoLocalize">true</bool>
                      <token name="AutomaticSize">0</token>
                      <Color3 name="BackgroundColor3">
                        <R>0.25882354378700256</R>
                        <G>0.25882354378700256</G>
                        <B>0.25882354378700256</B>
                      </Color3>
                      <float name="BackgroundTransparency">0.5</float>
                      <Color3 name="BorderColor3">
                        <R>0.0784313753247261</R>
                        <G>0.0784313753247261</G>
                        <B>0.0784313753247261</B>
                      </Color3>
                      <token name="BorderMode">2</token>
                      <int name="BorderSizePixel">7</int>
                      <bool name="ClipsDescendants">true</bool>
                      <bool name="Draggable">false</bool>
                      <int name="LayoutOrder">0</int>
                      <Ref name="NextSelectionDown">null</Ref>
                      <Ref name="NextSelectionLeft">null</Ref>
                      <Ref name="NextSelectionRight">null</Ref>
                      <Ref name="NextSelectionUp">null</Ref>
                      <UDim2 name="Position">
                        <XS>0</XS>
                        <XO>0</XO>
                        <YS>0</YS>
                        <YO>0</YO>
                      </UDim2>
                      <Ref name="RootLocalizationTable">null</Ref>
                      <float name="Rotation">0</float>
                      <bool name="Selectable">false</bool>
                      <Ref name="SelectionImageObject">null</Ref>
                      <UDim2 name="Size">
                        <XS>1</XS>
                        <XO>0</XO>
                        <YS>1</YS>
                        <YO>0</YO>
                      </UDim2>
                      <token name="SizeConstraint">0</token>
                      <int64 name="SourceAssetId">-1</int64>
                      <token name="Style">0</token>
                      <BinaryString name="Tags">
                      </BinaryString>
                      <bool name="Visible">true</bool>
                      <int name="ZIndex">1</int>
                    </Properties>
                  </Item>
                </Item>
                <Item class="TextLabel" referent="139">
                  <Properties>
                    <string name="Name">TextLabel</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>0</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <float name="BackgroundTransparency">1</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">1</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">17</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>0</XS>
                      <XO>10</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0.6000000238418579</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">Cameras</string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">13</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">0</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="140">
                  <Properties>
                    <string name="Name">Close</string>
                    <bool name="Active">true</bool>
                    <Vector2 name="AnchorPoint">
                      <X>1</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">false</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.7764706015586853</R>
                      <G>0.3490196168422699</G>
                      <B>0.3490196168422699</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">17</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">true</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0</XS>
                      <XO>20</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">X</string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">14</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">2</int>
                  </Properties>
                  <Item class="UICorner" referent="141">
                    <Properties>
                      <string name="Name">UICorner</string>
                      <BinaryString name="AttributesSerialize">
                      </BinaryString>
                      <UDim name="CornerRadius">
                        <S>0</S>
                        <O>10</O>
                      </UDim>
                      <int64 name="SourceAssetId">-1</int64>
                      <BinaryString name="Tags">
                      </BinaryString>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Frame" referent="142">
                  <Properties>
                    <string name="Name">CloseButtonOverlay1</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>1</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.7764706015586853</R>
                      <G>0.3490196168422699</G>
                      <B>0.3490196168422699</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>1</XS>
                      <XO>0</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0</XS>
                      <XO>20</XO>
                      <YS>0</YS>
                      <YO>10</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="Frame" referent="143">
                  <Properties>
                    <string name="Name">CloseButtonOverlay2</string>
                    <bool name="Active">false</bool>
                    <Vector2 name="AnchorPoint">
                      <X>1</X>
                      <Y>1</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.7764706015586853</R>
                      <G>0.3490196168422699</G>
                      <B>0.3490196168422699</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <int name="LayoutOrder">0</int>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>1</XS>
                      <XO>-10</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0</XS>
                      <XO>10</XO>
                      <YS>0</YS>
                      <YO>20</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">1</int>
                  </Properties>
                </Item>
                <Item class="TextButton" referent="144">
                  <Properties>
                    <string name="Name">Minimise</string>
                    <bool name="Active">true</bool>
                    <Vector2 name="AnchorPoint">
                      <X>1</X>
                      <Y>0</Y>
                    </Vector2>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <bool name="AutoButtonColor">true</bool>
                    <bool name="AutoLocalize">true</bool>
                    <token name="AutomaticSize">0</token>
                    <Color3 name="BackgroundColor3">
                      <R>0.22352942824363708</R>
                      <G>0.22352942824363708</G>
                      <B>0.22352942824363708</B>
                    </Color3>
                    <float name="BackgroundTransparency">0</float>
                    <Color3 name="BorderColor3">
                      <R>0.10588236153125763</R>
                      <G>0.16470588743686676</G>
                      <B>0.20784315466880798</B>
                    </Color3>
                    <token name="BorderMode">0</token>
                    <int name="BorderSizePixel">0</int>
                    <bool name="ClipsDescendants">false</bool>
                    <bool name="Draggable">false</bool>
                    <token name="Font">17</token>
                    <int name="LayoutOrder">0</int>
                    <float name="LineHeight">1</float>
                    <int name="MaxVisibleGraphemes">-1</int>
                    <bool name="Modal">false</bool>
                    <Ref name="NextSelectionDown">null</Ref>
                    <Ref name="NextSelectionLeft">null</Ref>
                    <Ref name="NextSelectionRight">null</Ref>
                    <Ref name="NextSelectionUp">null</Ref>
                    <UDim2 name="Position">
                      <XS>1</XS>
                      <XO>-20</XO>
                      <YS>0</YS>
                      <YO>0</YO>
                    </UDim2>
                    <bool name="RichText">false</bool>
                    <Ref name="RootLocalizationTable">null</Ref>
                    <float name="Rotation">0</float>
                    <bool name="Selectable">true</bool>
                    <bool name="Selected">false</bool>
                    <Ref name="SelectionImageObject">null</Ref>
                    <UDim2 name="Size">
                      <XS>0</XS>
                      <XO>20</XO>
                      <YS>1</YS>
                      <YO>0</YO>
                    </UDim2>
                    <token name="SizeConstraint">0</token>
                    <int64 name="SourceAssetId">-1</int64>
                    <token name="Style">0</token>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <string name="Text">-</string>
                    <Color3 name="TextColor3">
                      <R>1</R>
                      <G>1</G>
                      <B>1</B>
                    </Color3>
                    <bool name="TextScaled">false</bool>
                    <float name="TextSize">20</float>
                    <Color3 name="TextStrokeColor3">
                      <R>0</R>
                      <G>0</G>
                      <B>0</B>
                    </Color3>
                    <float name="TextStrokeTransparency">1</float>
                    <float name="TextTransparency">0</float>
                    <token name="TextTruncate">0</token>
                    <bool name="TextWrapped">false</bool>
                    <token name="TextXAlignment">2</token>
                    <token name="TextYAlignment">1</token>
                    <bool name="Visible">true</bool>
                    <int name="ZIndex">2</int>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="145">
              <Properties>
                <string name="Name">Other</string>
                <string name="Source">local utils = require(script.Parent.Utils)
local button = require(script.Parent.Parent.GuiComponents.RoundedButton)
local smoothGrid = require(script.Parent.SmoothGrid)
local other = {}

function other:generateButtonsForFolder(folder,parent,camType)
	local frame = utils:NewInstance("Frame", {
		BackgroundTransparency = 1,
		Size = UDim2.fromScale(1,1),
		AutomaticSize = Enum.AutomaticSize.Y,
		Parent = parent
	})
	local grid = utils:NewInstance("UIGridLayout", {
		CellSize = UDim2.fromOffset(100,30),
		Parent = frame
	})
	for i,v in pairs(folder:GetChildren()) do
		local button = button(v.Name)
		button.Parent = frame
		button.MouseButton1Click:Connect(function()
			script.Parent.Parent.Parent.Events.ChangeCam:FireServer(camType,v:GetAttribute("ID"))
		end)
	end
	smoothGrid(frame,grid)
end

return other</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="146">
              <Properties>
                <string name="Name">SmoothGrid</string>
                <string name="Source">return function(frame:GuiObject,grid:UIGridLayout,max:number)
	local padding = grid.CellPadding
	local size = grid.CellSize
	max = max or math.huge
	
	local function move(children)
		local buttonsPerRow = math.min(math.round(frame.AbsoluteSize.X / (size.X.Offset + padding.X.Offset)),max)
		local buttonXSize = frame.AbsoluteSize.X / buttonsPerRow - padding.X.Offset
		grid.CellSize = UDim2.new(0,buttonXSize,0,size.Y.Offset)
	end
	
	local children = frame:GetChildren()
	move(children)
	frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		move(children)
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="147">
              <Properties>
                <string name="Name">UpdateData</string>
                <string name="Source">local updateData = {}
local data = require(script.Parent.Parent.Parent.Data)

local onchangeEvents = {}

function updateData:get(name:string)
	local path = string.split(name,".")
	local val = data
	for i,v in pairs(path) do
		val = val[v]
	end
	return val
end

function updateData:getModule()
	return data
end

function updateData:set(name:string,val:any)
	local path = string.split(name,".")
	local toEdit = data
	for i = 1,#path-1 do
		toEdit = toEdit[path[i]]
	end
	toEdit[path[#path]] = val
	if onchangeEvents[name] then
		for i,v in pairs(onchangeEvents[name]) do
			task.spawn(function()
				v(val)
			end)
		end
	end
end

function updateData:onChange(name:string,func)
	if not onchangeEvents[name] then
		onchangeEvents[name] = {}
	end
	table.insert(onchangeEvents[name],func)
end

return updateData</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="148">
              <Properties>
                <string name="Name">Utils</string>
                <string name="Source">local utils = {}
local smoothGrid = require(script.Parent.SmoothGrid)

function utils:NewInstance(insName, params)
	local ins = Instance.new(insName)
	for i,v in pairs(params) do
		ins[i] = v
	end
	return ins
end

function utils:Round(num, places)
	places = math.pow(10, places or 0)
	num = num * places
	if num >= 0 then 
		num = math.floor(num + 0.5) 
	else 
		num = math.ceil(num - 0.5) 
	end
	return num / places
end

function utils:Map(n, oldMin, oldMax, min, max)
	return (min + ((max - min) * ((n - oldMin) / (oldMax - oldMin))))
end

return utils</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="149">
            <Properties>
              <string name="Name">Themes</string>
            </Properties>
            <Item class="ModuleScript" referent="150">
              <Properties>
                <string name="Name">Current</string>
                <string name="Source">local Settings = require(workspace:FindFirstChild("CameraSystem").Settings)
local theme = Settings.Theme or "Dark"
local themeScript = require(script.Parent[theme])
return themeScript</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="151">
              <Properties>
                <string name="Name">Dark</string>
                <string name="Source">return {
	
	Base = Color3.fromRGB(66,66,66),
	Underline = Color3.fromRGB(198,198,198),
	TransparentButton = Color3.fromRGB(59,59,59),
	RedButton = Color3.fromRGB(198,89,89),
	DarkerButton = Color3.fromRGB(57,57,57),
	
	BaseDarker = Color3.fromRGB(53, 53, 53),
	BaseDarker2 = Color3.fromRGB(0, 0, 0),

	BaseText = Color3.fromRGB(255,255,255),
	
	BaseBorder = Color3.fromRGB(20,20,20)
	
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="152">
              <Properties>
                <string name="Name">Light</string>
                <string name="Source">return {
	
	Base = Color3.fromRGB(235, 235, 235),
	Underline = Color3.fromRGB(27, 184, 198),
	TransparentButton = Color3.fromRGB(198, 198, 198),
	RedButton = Color3.fromRGB(198,89,89),
	DarkerButton = Color3.fromRGB(125, 125, 125),
	
	BaseDarker = Color3.fromRGB(189, 189, 189),
	BaseDarker2 = Color3.fromRGB(150, 150, 150),
	
	BaseText = Color3.fromRGB(0,0,0),

	BaseBorder = Color3.fromRGB(167, 167, 167)
	
}</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="153">
          <Properties>
            <string name="Name">Data</string>
            <string name="Source">local data = {
	
	Shared = {
		CurrentCamera = {
			Type = "Default",
			Id = 0,
			Model = nil
		},
		CameraData = {
			Position = Vector3.new(),
			Rotation = Vector3.new(),
			Focus = nil,
			CFrame = CFrame.new()
		}
	},
	
	Local = {
		Settings = {
			TransparentBlackout = false,
			Keybinds = false,
			DroneSpeed = 1
		}
	}

}

local run = game:GetService("RunService")
if run:IsClient() then
	local serverData = script.Parent.Events.RequestCurrentData:InvokeServer()
	data.Shared = serverData.Shared
end

return data</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="154">
          <Properties>
            <string name="Name">Events</string>
          </Properties>
          <Item class="RemoteEvent" referent="155">
            <Properties>
              <string name="Name">ChangeCam</string>
            </Properties>
          </Item>
          <Item class="RemoteFunction" referent="156">
            <Properties>
              <string name="Name">RequestCurrentData</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>